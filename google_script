/**
 * ERIC API Bridge Integration - Complete Google Apps Script
 * 
 * SETUP INSTRUCTIONS:
 * 1. Deploy your API bridge to Railway/Heroku
 * 2. Update CONFIG.API_BRIDGE_URL with your deployment URL
 * 3. Test with testApiBridgeIntegration() or testRailwayIntegration()
 * 4. Once working, run installTrigger() to set up automatic processing
 */

// --- CONFIGURATION ---
var CONFIG = {
  // UPDATE THIS WITH YOUR DEPLOYED API BRIDGE URL
  API_BRIDGE_URL: 'https://apibridge-production.up.railway.app/opportunities',
  
  // Your existing parser API (if you have one)
  PARSER_API_URL: 'https://karolyn-unmendacious-unsuccessively.ngrok-free.dev/api/parse',
  
  // Google Drive folder to monitor
  FOLDER_ID: '1NSsJLDQMYRiz-tX8LlN-ToNKBYRWV84F',
  
  // Other settings
  API_KEY: 'your-api-key-here',
  ERIC_WEBHOOK_URL: 'https://meet-eric.co/api/opportunities/review',
  
  // Google Maps API key for geolocation (replace with your actual API key)
  GOOGLE_MAPS_API_KEY: 'your-google-maps-api-key-here'
};

/**
 * üåç GEOLOCATION SERVICE - Convert location names to lat/lng coordinates
 */

/**
 * Convert a location name to latitude/longitude coordinates using Google Maps Geocoding API
 * @param {string} locationName The location name to geocode (e.g., "Manchester", "London, UK")
 * @returns {Object|null} Object with lat and lng properties, or null if geocoding fails
 */
function geocodeLocation(locationName) {
  if (!locationName || locationName.trim() === '') {
    return null;
  }
  
  // Check if we already have coordinates in cache to avoid API calls
  var cache = CacheService.getScriptCache();
  var cacheKey = 'geocode_' + locationName.toLowerCase().replace(/\s+/g, '_');
  var cached = cache.get(cacheKey);
  
  if (cached) {
    Logger.log('üåç GEOCODING: Using cached coordinates for ' + locationName);
    return JSON.parse(cached);
  }
  
  try {
    // Use Google Maps Geocoding API
    var geocodingUrl = 'https://maps.googleapis.com/maps/api/geocode/json?address=' + 
                      encodeURIComponent(locationName) + 
                      '&key=' + CONFIG.GOOGLE_MAPS_API_KEY;
    
    var response = UrlFetchApp.fetch(geocodingUrl);
    var data = JSON.parse(response.getContentText());
    
    if (data.status === 'OK' && data.results && data.results.length > 0) {
      var location = data.results[0].geometry.location;
      var result = {
        lat: location.lat,
        lng: location.lng
      };
      
      // Cache the result for 24 hours (86400 seconds)
      cache.put(cacheKey, JSON.stringify(result), 86400);
      
      Logger.log('üåç GEOCODING: Successfully geocoded "' + locationName + '" to lat: ' + result.lat + ', lng: ' + result.lng);
      return result;
      
    } else {
      Logger.log('‚ö†Ô∏è GEOCODING: Failed to geocode "' + locationName + '": ' + data.status);
      return null;
    }
    
  } catch (error) {
    Logger.log('‚ùå GEOCODING: Error geocoding "' + locationName + '": ' + error.toString());
    return null;
  }
}

/**
 * Fallback geocoding using a predefined list of UK cities (when API key is not available)
 * @param {string} locationName The location name to geocode
 * @returns {Object|null} Object with lat and lng properties, or null if not found
 */
function geocodeLocationFallback(locationName) {
  if (!locationName || locationName.trim() === '') {
    return null;
  }
  
  // Predefined coordinates for common UK locations
  var ukLocations = {
    'manchester': { lat: 53.4872927, lng: -2.2900071 },
    'london': { lat: 51.5074456, lng: -0.1277653 },
    'birmingham': { lat: 52.4796992, lng: -1.9026911 },
    'leeds': { lat: 53.7974185, lng: -1.5437941 },
    'glasgow': { lat: 55.8610306, lng: -4.2501671 },
    'liverpool': { lat: 53.4106086, lng: -2.9779312 },
    'bristol': { lat: 51.4538022, lng: -2.5972985 },
    'edinburgh': { lat: 55.9533456, lng: -3.1883749 },
    'cardiff': { lat: 51.4816546, lng: -3.1791353 },
    'belfast': { lat: 54.5946593, lng: -5.9690754 },
    'newcastle': { lat: 54.9738474, lng: -1.6131572 },
    'nottingham': { lat: 52.9534193, lng: -1.1496461 },
    'sheffield': { lat: 53.3806626, lng: -1.4702278 },
    'bradford': { lat: 53.7943026, lng: -1.7548636 },
    'coventry': { lat: 52.4082663, lng: -1.5105777 },
    'leicester': { lat: 52.6368778, lng: -1.1397592 },
    'sunderland': { lat: 54.9069619, lng: -1.3838009 },
    'plymouth': { lat: 50.3790795, lng: -4.1326565 },
    'derby': { lat: 52.9225301, lng: -1.4746186 },
    'wolverhampton': { lat: 52.5855681, lng: -2.1282226 },
    'salford': { lat: 53.4873218, lng: -2.2906621 },
    
    // PATCH28: Additional Scottish locations
    'milngavie': { lat: 55.9423, lng: -4.3177 },
    'east dunbartonshire': { lat: 55.9423, lng: -4.3177 }, // Use Milngavie coords for East Dunbartonshire
    'dunbartonshire': { lat: 55.9423, lng: -4.3177 },
    'stirling': { lat: 56.1165, lng: -3.9369 },
    'dundee': { lat: 56.4620, lng: -2.9707 },
    'aberdeen': { lat: 57.1497, lng: -2.0943 },
    'inverness': { lat: 57.4778, lng: -4.2247 },
    'perth': { lat: 56.3952, lng: -3.4304 },
    'falkirk': { lat: 56.0019, lng: -3.7841 },
    'ayr': { lat: 55.4639, lng: -4.6289 },
    'paisley': { lat: 55.8456, lng: -4.4337 },
    'hamilton': { lat: 55.7781, lng: -4.0589 },
    'kilmarnock': { lat: 55.6144, lng: -4.4985 },
    'cumbernauld': { lat: 55.9468, lng: -3.9963 },
    'greenock': { lat: 55.9485, lng: -4.7692 },
    
    // Additional English locations
    'reading': { lat: 51.4543, lng: -0.9781 },
    'oxford': { lat: 51.7520, lng: -1.2577 },
    'cambridge': { lat: 52.2053, lng: 0.1218 },
    'york': { lat: 53.9600, lng: -1.0873 },
    'bath': { lat: 51.3811, lng: -2.3590 },
    'chester': { lat: 53.1906, lng: -2.8837 },
    'preston': { lat: 53.7632, lng: -2.7031 },
    'blackpool': { lat: 53.8175, lng: -3.0357 },
    'bournemouth': { lat: 50.7192, lng: -1.8808 },
    'brighton': { lat: 50.8225, lng: -0.1372 },
    'portsmouth': { lat: 50.8058, lng: -1.0872 },
    'southampton': { lat: 50.9097, lng: -1.4044 },
    'exeter': { lat: 50.7236, lng: -3.5269 },
    'norwich': { lat: 52.6309, lng: 1.2974 },
    'ipswich': { lat: 52.0595, lng: 1.1550 },
    'canterbury': { lat: 51.2802, lng: 1.0789 },
    
    // Welsh locations
    'swansea': { lat: 51.6214, lng: -3.9436 },
    'newport': { lat: 51.5842, lng: -2.9977 },
    'wrexham': { lat: 53.0478, lng: -2.9916 },
    'bangor': { lat: 53.2280, lng: -4.1287 },
    
    // Northern Ireland locations
    'derry': { lat: 54.9966, lng: -7.3086 },
    'londonderry': { lat: 54.9966, lng: -7.3086 },
    'armagh': { lat: 54.3503, lng: -6.6528 },
    'newry': { lat: 54.1751, lng: -6.3402 },
    'lisburn': { lat: 54.5162, lng: -6.0581 },
    
    // Virtual locations
    'online': null, // No coordinates for online locations
    'remote': null, // No coordinates for remote locations
    'uk wide': null, // No specific coordinates for UK-wide opportunities
    'nationwide': null, // No specific coordinates for nationwide opportunities
    'virtual': null // No coordinates for virtual events
  };
  
  // First try exact match
  var key = locationName.toLowerCase().trim();
  var result = ukLocations[key];
  
  if (result) {
    Logger.log('üåç GEOCODING (Fallback): Found exact match for "' + locationName + '" - lat: ' + result.lat + ', lng: ' + result.lng);
    return result;
  } else if (result === null) {
    Logger.log('üåç GEOCODING (Fallback): "' + locationName + '" is a virtual location (no coordinates)');
    return null;
  }
  
  // PATCH28: Try partial matching for complex addresses
  Logger.log('üîç GEOCODING (Fallback): Trying partial match for "' + locationName + '"');
  
  // Sort cities by length (longest first) to match most specific location first
  var cityNames = Object.keys(ukLocations);
  cityNames.sort(function(a, b) { return b.length - a.length; });
  
  for (var i = 0; i < cityNames.length; i++) {
    var cityName = cityNames[i];
    var coords = ukLocations[cityName];
    
    if (coords !== null && key.indexOf(cityName) !== -1) {
      Logger.log('üåç GEOCODING (Fallback): Found partial match "' + cityName + '" in "' + locationName + '" - lat: ' + coords.lat + ', lng: ' + coords.lng);
      return coords;
    }
  }
  
  // Try word-based matching for better results
  Logger.log('üîç GEOCODING (Fallback): Trying word-based matching...');
  var words = key.split(/[\s,]+/); // Split on spaces and commas
  
  for (var j = 0; j < words.length; j++) {
    var word = words[j].trim();
    if (word.length > 2 && ukLocations[word]) { // Only check words longer than 2 chars
      var coords = ukLocations[word];
      if (coords !== null) {
        Logger.log('üåç GEOCODING (Fallback): Found word match "' + word + '" in "' + locationName + '" - lat: ' + coords.lat + ', lng: ' + coords.lng);
        return coords;
      }
    }
  }
  
  Logger.log('‚ö†Ô∏è GEOCODING (Fallback): No coordinates found for "' + locationName + '"');
  return null;
}

/**
 * Main geocoding function that tries Google Maps API first, then falls back to predefined list
 * @param {string} locationName The location name to geocode
 * @returns {Object|null} Object with lat and lng properties, or null if geocoding fails
 */
function getLocationCoordinates(locationName) {
  if (!locationName || locationName.trim() === '') {
    return null;
  }
  
  // Try Google Maps API first (if API key is configured)
  if (CONFIG.GOOGLE_MAPS_API_KEY && CONFIG.GOOGLE_MAPS_API_KEY !== 'your-google-maps-api-key-here') {
    var result = geocodeLocation(locationName);
    if (result) {
      return result;
    }
  }
  
  // Fall back to predefined list
  return geocodeLocationFallback(locationName);
}

/**
 * üß™ TEST FUNCTION - Run this first to test your deployment
 */
function testApiBridgeIntegration() {
  Logger.log('üß™ Testing API Bridge Integration...');
  
  var testData = {
    id: 'google-apps-script-test-' + Date.now(),
    opportunityType: 'Apprenticeship',
    title: 'Software Developer Apprentice - Test',
    shortSummary: 'This is a test opportunity sent from Google Apps Script to verify the integration is working.',
    location: 'Manchester, UK',
    applicationDeadline: '2025-12-31T23:59:59Z',
    link: 'https://example.com/apply-test',
    salary: '¬£18,000 per year',
    lengthOfApprenticeship: '18 months',
    levelOfApprenticeship: 'Level 4',
    anythingElseImportant: 'This is a test from Google Apps Script integration.',
    tags: {
      industry: ['Technology', 'Software Development'],
      keywords: ['apprentice', 'coding', 'test', 'google-apps-script']
    }
  };

  var result = sendToApiBridge(testData);
  
  if (result && result.success) {
    Logger.log('‚úÖ SUCCESS! Integration is working!');
    Logger.log('üî• Master Portal Doc ID: ' + result.masterPortalDocId);
    Logger.log('üìÅ Collection Path: ' + result.collectionPath);
    Logger.log('üéâ Your Google Apps Script ‚Üí API Bridge ‚Üí Firebase integration is live!');
    
    // Test different opportunity types
    Logger.log('üîÑ Testing Course opportunity type...');
    testCourseOpportunity();
  } else {
    Logger.log('‚ùå FAILED! Check your API_BRIDGE_URL and deployment.');
    Logger.log('Error: ' + (result ? result.error : 'Unknown error'));
  }
}

/**
 * üöÄ RAILWAY TEST FUNCTION - Specifically for testing Railway deployment
 */
function testRailwayIntegration() {
  Logger.log('üöÄ Testing Railway Integration...');
  Logger.log('üîó Railway URL: ' + CONFIG.API_BRIDGE_URL);
  
  var testData = {
    id: 'railway-google-apps-script-test-' + Date.now(),
    opportunityType: 'Apprenticeship',
    title: 'Railway Integration Test - Software Developer Apprentice',
    shortSummary: 'Testing the complete Railway ‚Üí API Bridge ‚Üí Firebase integration from Google Apps Script.',
    location: 'London, UK',
    applicationDeadline: '2025-12-31T23:59:59Z',
    link: 'https://example.com/apply-railway-test',
    salary: '¬£22,000 per year',
    lengthOfApprenticeship: '24 months',
    levelOfApprenticeship: 'Level 4',
    anythingElseImportant: 'This is a Railway deployment test from Google Apps Script.',
    tags: {
      industry: ['Technology', 'Software Development', 'Railway'],
      keywords: ['apprentice', 'railway', 'deployment', 'integration', 'test']
    }
  };

  var result = sendToApiBridge(testData);
  
  if (result && result.success) {
    Logger.log('üéâ RAILWAY SUCCESS! Integration is working perfectly!');
    Logger.log('üî• Master Portal Doc ID: ' + result.masterPortalDocId);
    Logger.log('üìÅ Collection Path: ' + result.collectionPath);
    Logger.log('üöÄ Railway URL: https://apibridge-production.up.railway.app');
    Logger.log('‚úÖ Your complete integration is live: Google Apps Script ‚Üí Railway ‚Üí Firebase!');
    
    return {
      success: true,
      masterPortalDocId: result.masterPortalDocId,
      railwayUrl: 'https://apibridge-production.up.railway.app'
    };
  } else {
    Logger.log('‚ùå RAILWAY TEST FAILED!');
    Logger.log('üîó URL: ' + CONFIG.API_BRIDGE_URL);
    Logger.log('Error: ' + (result ? result.error : 'Unknown error'));
    
    return {
      success: false,
      error: result ? result.error : 'Unknown error'
    };
  }
}

/**
 * üß™ Test Course Opportunity Type
 */
function testCourseOpportunity() {
  var courseData = {
    id: 'google-apps-script-course-test-' + Date.now(),
    opportunityType: 'Course',
    title: 'Full Stack Web Development Bootcamp - Test',
    shortSummary: 'Intensive bootcamp covering modern web development technologies.',
    location: 'Online',
    applicationDeadline: '2025-11-15T23:59:59Z',
    link: 'https://example.com/bootcamp-test',
    lengthOfCourse: '12 weeks',
    courseType: 'Paid',
    anythingElseImportant: 'Evening classes available. Portfolio projects included.',
    tags: {
      industry: ['Technology', 'Web Development', 'Education'],
      keywords: ['bootcamp', 'javascript', 'react', 'nodejs', 'full-stack']
    }
  };

  var result = sendToApiBridge(courseData);
  
  if (result && result.success) {
    Logger.log('‚úÖ Course test SUCCESS! Doc ID: ' + result.masterPortalDocId);
  } else {
    Logger.log('‚ùå Course test FAILED: ' + (result ? result.error : 'Unknown error'));
  }
}

/**
 * üß™ Test Demographics Integration - CRITICAL TEST!
 */
function testDemographicsIntegration() {
  Logger.log('üß™ Testing Demographics Integration...');
  
  var testData = {
    id: 'demographics-test-' + Date.now(),
    opportunityType: 'Apprenticeship',
    title: 'Demographics Test - Software Developer Apprentice',
    shortSummary: 'Testing demographic tag integration from Google Apps Script.',
    location: 'Manchester, UK',
    applicationDeadline: '2025-12-31T23:59:59Z',
    link: 'https://example.com/apply-demographics-test',
    salary: '¬£18,000 per year',
    lengthOfApprenticeship: '18 months',
    levelOfApprenticeship: 'Level 4',
    anythingElseImportant: 'CRITICAL: This test includes demographic keywords that should appear as Firebase tag IDs.',
    tags: {
      industry: ['Technology', 'Software Development'],
      keywords: ['apprentice', 'coding', 'He/Him', 'Asian or Asian British', 'Over 18', 'Neurodiversity']  // ‚Üê Fixed demographics!
    }
  };

  // This will go through normalizeOpportunityData and should populate tagsArr
  Logger.log('üü¶ Before normalization - tags.keywords: ' + JSON.stringify(testData.tags.keywords));
  
  var result = sendToApiBridge(testData);
  
  if (result && result.success) {
    Logger.log('üéâ DEMOGRAPHICS TEST SUCCESS!');
    Logger.log('üî• Master Portal Doc ID: ' + result.masterPortalDocId);
    Logger.log('üìã Check Firebase - should contain tag IDs for: He/Him, Asian or Asian British, Over 18, Neurodiversity');
    
    return {
      success: true,
      masterPortalDocId: result.masterPortalDocId,
      message: 'Demographics test completed - check Firebase for populated tags'
    };
  } else {
    Logger.log('‚ùå DEMOGRAPHICS TEST FAILED!');
    Logger.log('Error: ' + (result ? result.error : 'Unknown error'));
    
    return {
      success: false,
      error: result ? result.error : 'Unknown error'
    };
  }
}

/**
 * üß™ Test Specific Demographics Parsing - Comma-separated values
 */
function testSpecificDemographicsParsing() {
  Logger.log('üß™ Testing specific demographics parsing with comma-separated values...');
  
  var mockContent = `Event Title: Test Arts Residency
Event Description: A residency program for emerging artists with specific demographic targeting
Application Deadline: December 6th, 2025
Industry Tags: Arts, Creative Industries
Gender & Sexual Preference: Women, Non-binary, LGBTQ+, He/Him, She/Her, They/Them
Age: 18-25, Over 18
Ethnicity: BAME, Black, Asian
Disability: Neurodiversity, Physical disability
Economic Background: Working class, Low income`;

  Logger.log('üîç Parsing mock content with specific demographic criteria...');
  var parsedResult = parseTextFileInGoogleScript(mockContent);
  
  Logger.log('üìã Parsed keywords: ' + JSON.stringify(parsedResult.tags.keywords));
  Logger.log('üéØ Should contain individual demographic values like: Women, Non-binary, He/Him, She/Her, They/Them, 18-25, Over 18, BAME, Black, Asian, Neurodiversity, Working class, Low income');
  
  // Check if parsing correctly split comma-separated values
  var expectedValues = ['Women', 'Non-binary', 'LGBTQ+', 'He/Him', 'She/Her', 'They/Them', '18-25', 'Over 18', 'BAME', 'Black', 'Asian', 'Neurodiversity', 'Physical disability', 'Working class', 'Low income'];
  var foundValues = [];
  var missingValues = [];
  
  for (var i = 0; i < expectedValues.length; i++) {
    if (parsedResult.tags.keywords.indexOf(expectedValues[i]) !== -1) {
      foundValues.push(expectedValues[i]);
    } else {
      missingValues.push(expectedValues[i]);
    }
  }
  
  Logger.log('‚úÖ Found demographic values: ' + JSON.stringify(foundValues));
  if (missingValues.length > 0) {
    Logger.log('‚ùå Missing demographic values: ' + JSON.stringify(missingValues));
  }
  
  // Send through API bridge to test final demographic processing
  var result = sendToApiBridge(parsedResult);
  
  if (result && result.success) {
    Logger.log('üéâ SPECIFIC DEMOGRAPHICS TEST SUCCESS!');
    Logger.log('üî• Master Portal Doc ID: ' + result.masterPortalDocId);
    Logger.log('üìã Check Firebase - demographics should be specific, not defaulting to "All" arrays');
    
    return {
      success: true,
      masterPortalDocId: result.masterPortalDocId,
      message: 'Specific demographics parsing test completed - check Firebase for individual demographic tags'
    };
  } else {
    Logger.log('‚ùå SPECIFIC DEMOGRAPHICS TEST FAILED!');
    Logger.log('Error: ' + (result ? result.error : 'Unknown error'));
    
    return {
      success: false,
      error: result ? result.error : 'Unknown error'
    };
  }
}

/**
 * üß™ Test Empty Demographics - PATCH20 FIX TEST!
 */
function testEmptyDemographics() {
  Logger.log('üß™ Testing Empty Demographics (Patch20 Fix)...');
  
  var testData = {
    id: 'empty-demographics-test-' + Date.now(),
    opportunityType: 'Apprenticeship',
    title: 'Empty Demographics Test - Should Show Select Tags',
    shortSummary: 'Testing that opportunities with no demographic keywords result in empty demographic arrays.',
    location: 'Birmingham, UK',
    applicationDeadline: '2025-12-31T23:59:59Z',
    link: 'https://example.com/empty-demographics-test',
    salary: '¬£19,000 per year',
    lengthOfApprenticeship: '18 months',
    levelOfApprenticeship: 'Level 3',
    anythingElseImportant: 'EXPECTED: All demographic fields should be empty arrays, UI should show "Select tags" placeholders.',
    tags: {
      industry: ['Technology'],
      keywords: ['apprentice', 'coding', 'software'] // ‚Üê NO demographic keywords
    }
  };

  Logger.log('üü¶ Before normalization - tags.keywords: ' + JSON.stringify(testData.tags.keywords));
  Logger.log('üîç Expected: No demographic values should be found, all demographic arrays should be empty');
  
  var result = sendToApiBridge(testData);
  
  if (result && result.success) {
    Logger.log('üéâ EMPTY DEMOGRAPHICS TEST SUCCESS!');
    Logger.log('üî• Master Portal Doc ID: ' + result.masterPortalDocId);
    Logger.log('üìã Check Firebase - demographic object should have empty arrays for all categories');
    Logger.log('üéØ UI should show "Select tags" for: Age, Gender, Ethnicity, Disability, Socio-Economic');
    
    return {
      success: true,
      masterPortalDocId: result.masterPortalDocId,
      message: 'Empty demographics test completed - check UI shows "Select tags" placeholders'
    };
  } else {
    Logger.log('‚ùå EMPTY DEMOGRAPHICS TEST FAILED!');
    Logger.log('Error: ' + (result ? result.error : 'Unknown error'));
    
    return {
      success: false,
      error: result ? result.error : 'Unknown error'
    };
  }
}

/**
 * üß™ Test "All" Demographics Expansion - PATCH21 NEW TEST!
 */
function testAllDemographicsExpansion() {
  Logger.log('üß™ Testing "All" Demographics Expansion (Patch21 Fix)...');
  
  var testData = {
    id: 'all-demographics-expansion-test-' + Date.now(),
    opportunityType: 'Apprenticeship',
    title: 'All Demographics Expansion Test - Should Include All Individual Options',
    shortSummary: 'Testing that "All genders & preferences", "All ethnicities", etc. expand to include all individual demographic options.',
    location: 'London, UK',
    applicationDeadline: '2025-12-31T23:59:59Z',
    link: 'https://example.com/all-demographics-expansion-test',
    salary: '¬£25,000 per year',
    lengthOfApprenticeship: '24 months',
    levelOfApprenticeship: 'Level 4',
    anythingElseImportant: 'EXPECTED: Should expand to ALL individual options in each demographic category and include all in tags array.',
    tags: {
      industry: ['Technology'],
      keywords: ['apprentice', 'coding', 'All genders & preferences', 'All ethnicities', 'All ages', 'All disability', 'All backgrounds'] // ‚Üê ALL "All" options
    }
  };

  Logger.log('üü¶ Before normalization - tags.keywords: ' + JSON.stringify(testData.tags.keywords));
  Logger.log('üîç Expected: Should expand each "All" option to include all individual demographic values in that category');
  
  var result = sendToApiBridge(testData);
  
  if (result && result.success) {
    Logger.log('üéâ ALL DEMOGRAPHICS EXPANSION TEST SUCCESS!');
    Logger.log('üî• Master Portal Doc ID: ' + result.masterPortalDocId);
    Logger.log('üìã Check Firebase - should contain ALL individual demographic tag IDs for each category');
    Logger.log('üéØ Expected in tags array: He/Him, She/Her, They/Them, All ethnicities expanded, All ages expanded, etc.');
    Logger.log('üéØ UI should show all individual demographic options selected for each category');
    
    return {
      success: true,
      masterPortalDocId: result.masterPortalDocId,
      message: 'All demographics expansion test completed - check Firebase for all individual demographic IDs'
    };
  } else {
    Logger.log('‚ùå ALL DEMOGRAPHICS EXPANSION TEST FAILED!');
    Logger.log('Error: ' + (result ? result.error : 'Unknown error'));
    
    return {
      success: false,
      error: result ? result.error : 'Unknown error'
    };
  }
}

/**
 * üì§ Send data to API Bridge (your deployed service)
 */
function sendToApiBridge(opportunityData) {
  Logger.log('üì§ Sending to API Bridge: ' + opportunityData.title);
  
  var options = {
    method: 'post',
    contentType: 'application/json',
    payload: JSON.stringify(opportunityData),
    muteHttpExceptions: true
  };

  try {
    var response = UrlFetchApp.fetch(CONFIG.API_BRIDGE_URL, options);
    var responseCode = response.getResponseCode();
    var responseBody = response.getContentText();

    Logger.log('üì° API Bridge Response Code: ' + responseCode);

    if (responseCode === 200) {
      var result = JSON.parse(responseBody);
      Logger.log('‚úÖ API Bridge Success: ' + JSON.stringify(result, null, 2));
      return {
        success: true,
        masterPortalDocId: result.masterPortalDocId,
        collectionPath: result.collectionPath,
        data: result.data
      };
    } else {
      Logger.log('‚ùå API Bridge Error: ' + responseBody);
      return {
        success: false,
        error: 'HTTP ' + responseCode + ': ' + responseBody
      };
    }
  } catch (error) {
    Logger.log('‚ùå Network Error: ' + error.toString());
    return {
      success: false,
      error: 'Network Error: ' + error.toString()
    };
  }
}

/**
 * üîß PRODUCTION FUNCTIONS - Use these once testing works
 */

/**
 * Install trigger to monitor Google Drive folder
 */
function installTrigger() {
  // Delete any existing triggers
  var triggers = ScriptApp.getProjectTriggers();
  triggers.forEach(function(trigger) {
    if (trigger.getHandlerFunction() === 'checkFilesAndProcess') {
      ScriptApp.deleteTrigger(trigger);
    }
  });
  
  // Create new trigger (runs every 12 Hours)
  ScriptApp.newTrigger('checkFilesAndProcess')
    .timeBased()
    .everyHours(12)
    .create();
    
  Logger.log('‚úÖ Trigger installed! Will check for new files every 12 Hours.');
}

/**
 * Main function that processes files from Google Drive
 */
function checkFilesAndProcess() {
  try {
    Logger.log('üîç Checking for new files in Google Drive folder...');
    
    var folder = DriveApp.getFolderById(CONFIG.FOLDER_ID);
    var files = folder.getFiles();
    var processedCount = 0;
    
    while (files.hasNext()) {
      var file = files.next();
      
      if (isFileProcessed(file.getId())) {
        continue; // Skip already processed files
      }

      if (isSupportedFileType(file)) {
        try {
          Logger.log('üìÑ Processing: ' + file.getName());
          processDocument(file);
          markFileAsProcessed(file.getId(), 'success');
          processedCount++;
        } catch (e) {
          Logger.log('‚ùå Error processing ' + file.getName() + ': ' + e.toString());
          markFileAsProcessed(file.getId(), 'error');
        }
      } else {
        markFileAsProcessed(file.getId(), 'unsupported');
      }
    }
    
    if (processedCount > 0) {
      Logger.log('‚úÖ Processed ' + processedCount + ' new files.');
    } else {
      Logger.log('‚ÑπÔ∏è No new files to process.');
    }
  } catch (e) {
    Logger.log('‚ùå Fatal error in checkFilesAndProcess: ' + e.toString());
  }
}

/**
 * Parse application deadline from human-readable format to ISO string.
 * @param {string} dateString The human-readable date string.
 * @returns {string} ISO formatted date string.
 */
function parseApplicationDeadline(dateString) {
  if (!dateString || dateString.trim() === '') {
    return '';
  }
  
  var cleanDate = dateString.trim();
  
  // Remove ordinal suffixes (1st, 2nd, 3rd, 4th, etc.)
  cleanDate = cleanDate.replace(/(\d+)(st|nd|rd|th)/gi, '$1');
  
  try {
    // Handle common patterns
    // "5th December 2025" -> "5 December 2025" -> "2025-12-05T23:59:59Z"
    // "December 5, 2025" -> "2025-12-05T23:59:59Z"
    // "14 December 2025 for Term 2" -> "2025-12-14T23:59:59Z"
    // "5/12/25" -> "2025-12-05T23:59:59Z"
    // "2025-12-05" -> "2025-12-05T23:59:59Z"
    
    var date = null;
    
    // Pattern 1: Extract first date from complex strings like "14 December 2025 for Term 2"
    var complexDatePattern = /(\d{1,2})\s+(\w+)\s+(\d{4})/i;
    var complexMatch = cleanDate.match(complexDatePattern);
    if (complexMatch) {
      var day = parseInt(complexMatch[1]);
      var monthName = complexMatch[2];
      var year = parseInt(complexMatch[3]);
      
      var months = {
        'january': 0, 'february': 1, 'march': 2, 'april': 3, 'may': 4, 'june': 5,
        'july': 6, 'august': 7, 'september': 8, 'october': 9, 'november': 10, 'december': 11
      };
      
      var monthIndex = months[monthName.toLowerCase()];
      if (monthIndex !== undefined) {
        date = new Date(year, monthIndex, day, 23, 59, 59);
        Logger.log('üîç DATE PARSER: Extracted date from complex string: ' + day + ' ' + monthName + ' ' + year);
      }
    }
    
    // Pattern 1B: Handle dates without year like "14 December" - assume current year or next year
    if (!date) {
      var noYearPattern = /(\d{1,2})\s+(\w+)/i;
      var noYearMatch = cleanDate.match(noYearPattern);
      if (noYearMatch) {
        var day = parseInt(noYearMatch[1]);
        var monthName = noYearMatch[2];
        var currentYear = new Date().getFullYear();
        
        var months = {
          'january': 0, 'february': 1, 'march': 2, 'april': 3, 'may': 4, 'june': 5,
          'july': 6, 'august': 7, 'september': 8, 'october': 9, 'november': 10, 'december': 11
        };
        
        var monthIndex = months[monthName.toLowerCase()];
        if (monthIndex !== undefined) {
          // Try current year first
          var testDate = new Date(currentYear, monthIndex, day);
          var now = new Date();
          
          // If the date is in the past, use next year
          var year = (testDate < now) ? currentYear + 1 : currentYear;
          
          date = new Date(year, monthIndex, day, 23, 59, 59);
          Logger.log('üîç DATE PARSER: Extracted date without year: ' + day + ' ' + monthName + ' -> ' + year);
        }
      }
    }
    
    // Pattern 2: "5th December 2025", "1st January 2024", etc.
    if (!date) {
      var ordinalPattern = /(\d{1,2})(st|nd|rd|th)\s+(\w+)\s+(\d{4})/i;
      var ordinalMatch = cleanDate.match(ordinalPattern);
      if (ordinalMatch) {
        var day = parseInt(ordinalMatch[1]);
        var monthName = ordinalMatch[3];
        var year = parseInt(ordinalMatch[4]);
        
        var months = {
          'january': 0, 'february': 1, 'march': 2, 'april': 3, 'may': 4, 'june': 5,
          'july': 6, 'august': 7, 'september': 8, 'october': 9, 'november': 10, 'december': 11
        };
        
        var monthIndex = months[monthName.toLowerCase()];
        if (monthIndex !== undefined) {
          date = new Date(year, monthIndex, day, 23, 59, 59);
        }
      }
    }
    
    // Pattern 3: Try standard JavaScript Date parsing
    if (!date) {
      date = new Date(cleanDate);
      if (isNaN(date.getTime())) {
        date = null;
      }
    }
    
    // Pattern 4: Try with added time if no time specified
    if (!date && !cleanDate.includes('T') && !cleanDate.includes(':')) {
      date = new Date(cleanDate + ' 23:59:59');
      if (isNaN(date.getTime())) {
        date = null;
      }
    }
    
    if (date && !isNaN(date.getTime())) {
      // Set to end of day (23:59:59) for deadlines
      date.setHours(23, 59, 59, 999);
      Logger.log('üîç DATE PARSER: Successfully parsed to ISO: ' + date.toISOString());
      return date.toISOString();
    }
    
    // If all parsing fails, check for special cases
    if (dateString.toLowerCase().includes('not specified') || 
        dateString.toLowerCase().includes('n/a') || 
        dateString.toLowerCase().includes('tbc') ||
        dateString.toLowerCase().includes('to be confirmed')) {
      Logger.log('‚ö†Ô∏è Could not parse date: ' + dateString + ', returning "No deadline specified"');
      return 'No deadline specified';
    }
    
    // Return original string for other cases
    Logger.log('‚ö†Ô∏è Could not parse date: ' + dateString + ', returning original');
    return dateString;
    
  } catch (e) {
    Logger.log('‚ö†Ô∏è Date parsing error for "' + dateString + '": ' + e.toString());
    return dateString;
  }
}

/**
 * Parse text file format into JSON structure (Google Apps Script version).
 * Handles key: value pairs and converts demographic text values into proper arrays.
 * @param {string} textContent The raw text content from the file.
 * @returns {Object} The parsed JSON structure.
 */
function parseTextFileInGoogleScript(textContent) {
  Logger.log('üîç TEXT PARSER (Google Script): Starting text file parsing...');
  
  var lines = textContent.split('\n').map(function(line) { return line.trim(); }).filter(function(line) { return line; });
  var eventDate = ''; // Store event date for deadline fallback
  var result = {
    title: '',
    description: '',
    shortSummary: '',
    link: '',
    applicationDeadline: '',
    location: '',
    remote: false,
    ukWide: false,
    opportunityType: 'Course', // Default for this type of content - FIXED
    status: 'live', // Set status to live by default - FIXED
    salary: '',
    lengthOfApprenticeship: '',
    lengthOfInternship: '',
    lengthOfCourse: '', // Added for course support
    courseType: '', // Added for course support
    anythingElseImportant: '',
    _geoloc: null, // Will be populated with {lat: number, lng: number} if location is geocoded
    tags: {
      industry: [],
      keywords: []
    }
  };

  // Enhanced parsing to handle multi-line sections
  for (var i = 0; i < lines.length; i++) {
    var line = lines[i];
    if (!line.includes(':')) continue;
    
    var parts = line.split(':');
    var key = parts[0].trim();
    var value = parts.slice(1).join(':').trim();
    
    // Check for multi-line sections like "Important details:"
    if ((key === 'Important details' || key === 'Important Details') && (!value || value === '')) {
      // Collect all following lines until we hit another field with a colon
      var multiLineContent = [];
      var j = i + 1;
      while (j < lines.length && !lines[j].includes(':')) {
        if (lines[j].trim()) {
          multiLineContent.push(lines[j]);
        }
        j++;
      }
      if (multiLineContent.length > 0) {
        value = multiLineContent.join('\n');
        i = j - 1; // Skip the lines we just processed
      }
    }
    
    Logger.log('üîç TEXT PARSER: Processing "' + key + '" = "' + value + '"');
    
    switch (key) {
      case 'Salary':
        result.salary = value;
        break;
        
      case 'Length of internship & start date/ month':
      case 'Length of internship':
        result.lengthOfInternship = value;
        break;
        
      case 'Length of course':
        result.lengthOfCourse = value;
        // Also set opportunityType to Course if we see course-related fields
        result.opportunityType = 'Course';
        Logger.log('üîç TEXT PARSER: Set opportunityType to Course, lengthOfCourse: ' + value);
        break;
        
      case 'Course type':
        result.courseType = value;
        result.opportunityType = 'Course';
        Logger.log('üîç TEXT PARSER: Set opportunityType to Course, courseType: ' + value);
        break;
        
      case 'Application deadline':
        // Parse human-readable date formats into ISO format
        result.applicationDeadline = parseApplicationDeadline(value);
        Logger.log('üîç TEXT PARSER: Parsed deadline "' + value + '" to "' + result.applicationDeadline + '"');
        break;
        
      case 'Location':
        result.location = value;
        // Add geolocation coordinates for the location
        var coordinates = getLocationCoordinates(value);
        if (coordinates) {
          result._geoloc = {
            lat: coordinates.lat,
            lng: coordinates.lng
          };
          Logger.log('üåç TEXT PARSER: Added geolocation for "' + value + '" - lat: ' + coordinates.lat + ', lng: ' + coordinates.lng);
        } else {
          Logger.log('‚ö†Ô∏è TEXT PARSER: Could not geocode location "' + value + '"');
        }
        break;
        
      case 'Anything else important':
        result.anythingElseImportant = value;
        result.shortSummary = value.length > 200 ? value.substring(0, 200) + '...' : value;
        break;
        
      case 'Link':
        result.link = value;
        break;
        
      case '- Website':
      case 'Website':
      case 'Company Website':
      case 'Apply Link':
      case 'Application Link':
        // Capture website/application links
        if (!result.link && value) {
          result.link = value;
          Logger.log('üîç TEXT PARSER: Set link from ' + key + ': ' + value);
        }
        break;
        
      case 'Title':
        // Use title from file if provided
        if (value && value.trim()) {
          result.title = value.trim();
          Logger.log('üîç TEXT PARSER: Set title from file: ' + value);
        }
        break;
        
      case 'Type':
        // Handle opportunity type from file
        if (value && value.trim()) {
          var typeValue = value.trim();
          if (typeValue.toLowerCase().includes('part-time')) {
            result.opportunityType = 'Junior part-time role';
          } else if (typeValue.toLowerCase().includes('full-time')) {
            result.opportunityType = 'Junior full-time role';
          } else if (typeValue.toLowerCase().includes('apprentice')) {
            result.opportunityType = 'Apprenticeship';
          } else if (typeValue.toLowerCase().includes('internship')) {
            result.opportunityType = 'Internship';
          } else if (typeValue.toLowerCase().includes('course')) {
            result.opportunityType = 'Course';
          }
          Logger.log('üîç TEXT PARSER: Set opportunityType from Type field: ' + result.opportunityType);
        }
        break;
        
      case 'Remote':
        result.remote = value.toLowerCase() === 'yes' || value.toLowerCase() === 'true';
        break;
        
      case 'UK Wide':
        result.ukWide = value.toLowerCase() === 'yes' || value.toLowerCase() === 'true';
        break;
        
      case 'Industry':
      case 'Industry Tags':
        // Split comma-separated values and clean them
        result.tags.industry = value.split(',')
          .map(function(item) { return item.trim(); })
          .filter(function(item) { return item; });
        Logger.log('üîç TEXT PARSER: Parsed industries: ' + JSON.stringify(result.tags.industry));
        break;
        
      case 'Age':
      case 'Age Tags':
        // Split comma-separated age values and add individually
        if (value && value.trim()) {
          var ageValues = value.split(',').map(function(item) { return item.trim(); });
          result.tags.keywords = result.tags.keywords.concat(ageValues);
          Logger.log('üîç TEXT PARSER: Added age values to keywords: ' + JSON.stringify(ageValues));
        }
        break;
        
      case 'Gender & Sexual Preference':
      case 'Gender & Sexual Preference Tags':
        // Split comma-separated demographic values and add individually
        if (value && value.trim()) {
          var genderValues = value.split(',').map(function(item) { return item.trim(); });
          result.tags.keywords = result.tags.keywords.concat(genderValues);
          Logger.log('üîç TEXT PARSER: Added gender values to keywords: ' + JSON.stringify(genderValues));
        }
        break;
        
      case 'Ethnicity':
      case 'Ethnicity Tags':
        // Split comma-separated demographic values and add individually
        if (value && value.trim()) {
          var ethnicityValues = value.split(',').map(function(item) { return item.trim(); });
          result.tags.keywords = result.tags.keywords.concat(ethnicityValues);
          Logger.log('üîç TEXT PARSER: Added ethnicity values to keywords: ' + JSON.stringify(ethnicityValues));
        }
        break;
        
      case 'Disability':
      case 'Disability Tags':
        // Split comma-separated demographic values and add individually
        if (value && value.trim()) {
          var disabilityValues = value.split(',').map(function(item) { return item.trim(); });
          result.tags.keywords = result.tags.keywords.concat(disabilityValues);
          Logger.log('üîç TEXT PARSER: Added disability values to keywords: ' + JSON.stringify(disabilityValues));
        }
        break;
        
      case 'Economic Background':
      case 'Economic Background Tags':
        // Split comma-separated demographic values and add individually
        if (value && value.trim()) {
          var economicValues = value.split(',').map(function(item) { return item.trim(); });
          result.tags.keywords = result.tags.keywords.concat(economicValues);
          Logger.log('üîç TEXT PARSER: Added economic background values to keywords: ' + JSON.stringify(economicValues));
        }
        break;
        
      case 'Region':
        // Use region info if no specific location
        if (!result.location || result.location === '') {
          result.location = value;
        }
        break;
        
      case 'Event Title':
        // Use event title as the main title
        if (value && value.trim()) {
          result.title = value.trim();
          Logger.log('üîç TEXT PARSER: Set title from Event Title: ' + value);
        }
        break;
        
      case 'Event Description':
        // Use event description as main content
        if (value && value.trim()) {
          result.anythingElseImportant = value;
          result.shortSummary = value.length > 200 ? value.substring(0, 200) + '...' : value;
          result.description = value;
          Logger.log('üîç TEXT PARSER: Set event description');
        }
        break;
        
      case 'Event Date':
        // Capture event date information and store for deadline fallback
        if (value && value.trim()) {
          eventDate = value.trim(); // Store for potential deadline use
          if (result.anythingElseImportant) {
            result.anythingElseImportant += '\n\nEvent Date: ' + value;
          } else {
            result.anythingElseImportant = 'Event Date: ' + value;
          }
          Logger.log('üîç TEXT PARSER: Added event date info and stored for deadline fallback');
        }
        break;
        
      case 'Event Time':
        // Capture event time information
        if (value && value.trim()) {
          if (result.anythingElseImportant) {
            result.anythingElseImportant += '\nEvent Time: ' + value;
          } else {
            result.anythingElseImportant = 'Event Time: ' + value;
          }
          Logger.log('üîç TEXT PARSER: Added event time info');
        }
        break;
        
      case 'Cost':
        // Capture cost information
        if (value && value.trim()) {
          if (result.anythingElseImportant) {
            result.anythingElseImportant += '\nCost: ' + value;
          } else {
            result.anythingElseImportant = 'Cost: ' + value;
          }
          Logger.log('üîç TEXT PARSER: Added cost info');
        }
        break;
        
      case '- Age requirement':
      case 'Age requirement':
        // Capture age requirements
        if (value && value.trim()) {
          if (result.anythingElseImportant) {
            result.anythingElseImportant += '\nAge Requirement: ' + value;
          } else {
            result.anythingElseImportant = 'Age Requirement: ' + value;
          }
          Logger.log('üîç TEXT PARSER: Added age requirement');
        }
        break;
        
      case '- Contact for accessibility or event questions':
      case 'Contact for accessibility':
      case 'Event contact':
        // Capture contact information
        if (value && value.trim()) {
          if (result.anythingElseImportant) {
            result.anythingElseImportant += '\nContact: ' + value;
          } else {
            result.anythingElseImportant = 'Contact: ' + value;
          }
          Logger.log('üîç TEXT PARSER: Added contact info');
        }
        break;
        
      case '- Daniel Regan':
      case '- Sam Ulla Lindsay':
      case 'Artists Info':
        // Capture artist/presenter information
        if (value && value.trim()) {
          var fieldName = key.startsWith('- ') ? key.substring(2) : key;
          if (result.anythingElseImportant) {
            result.anythingElseImportant += '\n\n' + fieldName + ': ' + value;
          } else {
            result.anythingElseImportant = fieldName + ': ' + value;
          }
          Logger.log('üîç TEXT PARSER: Added artist/presenter info');
        }
        break;
        
      case 'Tags':
        // Handle additional tags field
        if (value && value.trim()) {
          var additionalTags = value.split(',').map(function(tag) { return tag.trim(); });
          result.tags.keywords = result.tags.keywords.concat(additionalTags);
          Logger.log('üîç TEXT PARSER: Added additional tags: ' + JSON.stringify(additionalTags));
        }
        break;
        
      case 'Important details':
      case 'Important Details':
        // Handle important details field specifically
        if (value && value.trim()) {
          result.anythingElseImportant = value;
          result.description = value;
          result.shortSummary = value.length > 200 ? value.substring(0, 200) + '...' : value;
          Logger.log('üîç TEXT PARSER: Set important details as main content');
        }
        break;
        
      case 'Key Responsibilities':
      case 'Skills & Experience':
      case 'Essential':
      case 'Desirable':
      case 'How to Apply':
      case 'Description':
      case 'Job Description':
        // Add important details to anythingElseImportant
        if (value && value.trim()) {
          if (result.anythingElseImportant) {
            result.anythingElseImportant += '\n\n' + key + ': ' + value;
          } else {
            result.anythingElseImportant = key + ': ' + value;
          }
          // Also update shortSummary if it's empty
          if (!result.shortSummary) {
            result.shortSummary = value.length > 200 ? value.substring(0, 200) + '...' : value;
          }
          Logger.log('üîç TEXT PARSER: Added ' + key + ' to anythingElseImportant');
        }
        break;
        
      default:
        Logger.log('üîç TEXT PARSER: Unhandled field "' + key + '" = "' + value + '"');
        break;
    }
  }

  // Generate title if not set
  if (!result.title || result.title.trim() === '') {
    var industryText = result.tags.industry.length > 0 ? result.tags.industry[0] : 'Opportunity';
    // Use opportunityType to determine title
    if (result.opportunityType === 'Course') {
      result.title = industryText + ' Course';
    } else if (result.opportunityType === 'Junior part-time role') {
      result.title = industryText + ' Part-Time Role';
    } else if (result.opportunityType === 'Junior full-time role') {
      result.title = industryText + ' Full-Time Role';
    } else if (result.opportunityType === 'Apprenticeship') {
      result.title = industryText + ' Apprenticeship';
    } else if (result.opportunityType === 'Internship') {
      result.title = industryText + ' Internship';
    } else {
      result.title = industryText + ' Opportunity';
    }
  }
  
  // Add some basic keywords based on opportunity type
  if (result.opportunityType === 'Course') {
    result.tags.keywords = result.tags.keywords.concat(['course', 'opportunity']);
  } else {
    result.tags.keywords = result.tags.keywords.concat(['internship', 'opportunity']);
  }

  // Use event date as deadline if no specific deadline was provided
  if (eventDate && (result.applicationDeadline === 'No deadline specified' || !result.applicationDeadline)) {
    result.applicationDeadline = parseApplicationDeadline(eventDate);
    Logger.log('üîç TEXT PARSER: Using event date as deadline: ' + result.applicationDeadline);
  }

  Logger.log('üîç TEXT PARSER (Google Script): Final parsed result: ' + JSON.stringify(result, null, 2));
  return result;
}

/**
 * Process a single document file
 */
function processDocument(file) {
  // --- NORMALIZATION FUNCTION ---
  function normalizeOpportunityData(data) {
    // Helper functions
    function arr(val) { return Array.isArray(val) ? val : (val ? [val] : []); }
    function str(val) { return typeof val === 'string' ? val : ''; }
    function bool(val) { return typeof val === 'boolean' ? val : false; }
    function strOrNull(val) { return val === null ? null : str(val); }
    function id(val) { return typeof val === 'string' ? val : (val ? String(val) : ''); }

    // Allowed categories: label and value (frontend expects value)
    var allowedCategories = [
      { label: 'Apprenticeship', name: 'apprenticeship' },
      { label: 'Competition/Grant', name: 'competition-grant' },
      { label: 'Course', name: 'course' },
      { label: 'Freelance role', name: 'freelance-role' },
      { label: 'Internship', name: 'internship' },
      { label: 'Junior full-time role', name: 'junior-full-time-role' },
      { label: 'Junior part-time role', name: 'junior-part-time-role' },
      { label: 'Mentoring', name: 'mentoring' },
      { label: 'Opportunity', name: 'opportunity' },
      { label: 'Runner role', name: 'runner-role' },
      { label: 'Training scheme', name: 'training-scheme' },
      { label: 'Work experience', name: 'work-experience' }
    ];

    // Find best match for category (label or value)
    function mapCategory(val) {
      var v = str(val).trim();
      if (!v) return '';
      // Try label match (case-insensitive)
      var found = allowedCategories.find(function(opt) { return opt.label.toLowerCase() === v.toLowerCase(); });
      if (found) return found.name;
      // Try value match (case-insensitive)
      found = allowedCategories.find(function(opt) { return opt.name.toLowerCase() === v.toLowerCase(); });
      if (found) return found.name;
      return '';
    }

    var rawCat = str(data.category) || str(data.opportunityType);
    var mappedCat = mapCategory(rawCat);
    
    // Only if not matched, try to infer from filename or tags
    if (!mappedCat) {
      var title = str(data.title).toLowerCase();
      var idVal = str(data.id).toLowerCase();
      var keywords = [];
      if (Array.isArray(data.tags)) {
        data.tags.forEach(function(tagObj) {
          if (tagObj && Array.isArray(tagObj.keywords)) {
            keywords = keywords.concat(tagObj.keywords.map(function(k){return String(k).toLowerCase();}));
          }
        });
      }
      if (title.includes('apprentice') || idVal.includes('apprentice') || keywords.includes('apprentice')) mappedCat = 'apprenticeship';
      else if (title.includes('intern') || idVal.includes('intern') || keywords.includes('intern')) mappedCat = 'internship';
      else if (title.includes('course') || idVal.includes('course') || keywords.includes('course')) mappedCat = 'course';
      else if (title.includes('training') || idVal.includes('training') || keywords.includes('training')) mappedCat = 'training-scheme';
      else if (title.includes('runner') || idVal.includes('runner') || keywords.includes('runner')) mappedCat = 'runner-role';
      else if (title.includes('freelance') || idVal.includes('freelance') || keywords.includes('freelance')) mappedCat = 'freelance-role';
      else if (title.includes('competition') || idVal.includes('competition') || keywords.includes('competition') || title.includes('grant') || idVal.includes('grant') || keywords.includes('grant')) mappedCat = 'competition-grant';
      else if (title.includes('junior') && title.includes('full') && title.includes('time')) mappedCat = 'junior-full-time-role';
      else if (title.includes('junior') && title.includes('part') && title.includes('time')) mappedCat = 'junior-part-time-role';
      else if (title.includes('mentor') || idVal.includes('mentor') || keywords.includes('mentor')) mappedCat = 'mentoring';
      else if (title.includes('work experience') || idVal.includes('work experience') || keywords.includes('work experience')) mappedCat = 'work-experience';
      else if (title.includes('job') || idVal.includes('job') || keywords.includes('job')) mappedCat = 'junior-full-time-role';
      else mappedCat = 'opportunity';
    }

    // Allowed industries (case-insensitive match)
    var allowedIndustries = [
      'All Creative Industries', 'Acting', 'Advertising', 'Animation', 'Architecture', 'Arts', 'Audio', 'Comedy', 'Content Creation', 'Craft', 'Culture', 'Dance', 'Design', 'Digital', 'Directing', 'E-Sport', 'Fashion', 'Film', 'Gaming', 'Graphic Design', 'Heritage', 'Journalism', 'Marketing', 'Media', 'Museum', 'Music', 'Performing Arts', 'Photography', 'Podcasting', 'PR', 'Presenting', 'Publishing', 'Radio', 'Social Media', 'Theatre', 'TV', 'UX/UI Design', 'VFX', 'Videography', 'Visual Art', 'Writing'
    ];

    // Normalize industry tags: always array, only allowed values, case-insensitive
    function normalizeIndustries(input) {
      var arrInput = Array.isArray(input) ? input : (input ? [input] : []);
      return arrInput
        .map(function(val) { return String(val).trim(); })
        .filter(function(val) {
          return allowedIndustries.some(function(ai) { return ai.toLowerCase() === val.toLowerCase(); });
        })
        .map(function(val) {
          // Return the canonical casing from allowedIndustries
          var found = allowedIndustries.find(function(ai) { return ai.toLowerCase() === val.toLowerCase(); });
          return found || val;
        });
    }

    // Extract industry tags from data.tags.industry or data.industry
    var industryTags = [];
    if (data.tags && Array.isArray(data.tags.industry)) {
      industryTags = normalizeIndustries(data.tags.industry);
    } else if (Array.isArray(data.industry)) {
      industryTags = normalizeIndustries(data.industry);
    }
    if (!industryTags) industryTags = [];

    // Extract keywords from data.tags.keywords or data.keywords
    var keywordsArr = [];
    if (data.tags && Array.isArray(data.tags.keywords)) {
      keywordsArr = data.tags.keywords.map(function(k) { return String(k); });
    } else if (Array.isArray(data.keywords)) {
      keywordsArr = data.keywords.map(function(k) { return String(k); });
    }
    if (!keywordsArr) keywordsArr = [];

    // *** FIX: Build tagsArr to include ALL tags (industry + keywords + demographic values) ***
    var tagsArr = [];
    
    // Add industry tags
    tagsArr = tagsArr.concat(industryTags);
    
    // Add keyword tags
    tagsArr = tagsArr.concat(keywordsArr);

    // Define allowed demographic values (PATCH29: Fixed to match portal UI expectations exactly)
    var allowedAges = ['21','22','23','24','25','Over 18','Under 18','Over 25','16 and under', '18+ only', 'All ages'];
    var allowedGenders = ['He/Him', 'She/Her', 'They/Them', 'Non-binary', 'Transgender', 'Intersex', 'Other', 'Prefer not to say', 'All genders & preferences'];
    var allowedEthnicities = ['White or White British', 'African, Caribbean or Black British', 'Asian or Asian British', 'Mixed or Multiple Ethnic group', 'Other Ethnic Group', 'Arab', 'Prefer not to say', 'All ethnicities'];
    var allowedDisabilities = ['Chronic illness', 'Hearing impairment', 'Neurodiversity', 'Physical disability', 'Visual impairment', 'Mental health', 'All disability'];
    var allowedSocioEconomic = ['All backgrounds', 'Only those from lower socio-economic background', 'Have or had free school meals', 'Lower socio-economic background'];
    
    // Define what "All" options expand to (PATCH29: Added portal-compatible options)
    var allAgeOptions = ['21','22','23','24','25','Over 18','Under 18','Over 25','16 and under', '18+ only'];
    var allGenderOptions = ['He/Him', 'She/Her', 'They/Them', 'Non-binary', 'Transgender', 'Intersex', 'Other', 'Prefer not to say'];
    var allEthnicityOptions = ['White or White British', 'African, Caribbean or Black British', 'Asian or Asian British', 'Mixed or Multiple Ethnic group', 'Other Ethnic Group', 'Arab', 'Prefer not to say'];
    var allDisabilityOptions = ['Chronic illness', 'Hearing impairment', 'Neurodiversity', 'Physical disability', 'Visual impairment', 'Mental health'];
    var allSocioEconomicOptions = ['All backgrounds', 'Only those from lower socio-economic background', 'Have or had free school meals', 'Lower socio-economic background'];

    // Extract demographic values and add them to tagsArr (PATCH21: Handle "All" expansions)
    var ageString = '';
    var genderString = '';
    var ethnicityString = '';
    var disabilityString = '';
    var lowerSocioEconomicBackgroundString = '';
    var ageTagsToAdd = [];
    var genderTagsToAdd = [];
    var ethnicityTagsToAdd = [];
    var disabilityTagsToAdd = [];
    var socioEconomicTagsToAdd = [];

    // Collect ALL matching demographic values from keywords (FIXED: collect all matches, not just first)
    var ageMatches = [];
    var genderMatches = [];
    var ethnicityMatches = [];
    var disabilityMatches = [];
    var socioEconomicMatches = [];

    // Find all age matches in keywords
    for (var i = 0; i < keywordsArr.length; i++) {
      if (allowedAges.includes(keywordsArr[i])) {
        ageMatches.push(keywordsArr[i]);
      }
    }

    // Find all gender matches in keywords
    for (var j = 0; j < keywordsArr.length; j++) {
      if (allowedGenders.includes(keywordsArr[j])) {
        genderMatches.push(keywordsArr[j]);
      }
    }

    // Find all ethnicity matches in keywords
    for (var k = 0; k < keywordsArr.length; k++) {
      if (allowedEthnicities.includes(keywordsArr[k])) {
        ethnicityMatches.push(keywordsArr[k]);
      }
    }

    // Find all disability matches in keywords
    for (var d = 0; d < keywordsArr.length; d++) {
      if (allowedDisabilities.includes(keywordsArr[d])) {
        disabilityMatches.push(keywordsArr[d]);
      }
    }

    // Find all socioeconomic matches in keywords
    for (var l = 0; l < keywordsArr.length; l++) {
      if (allowedSocioEconomic.includes(keywordsArr[l])) {
        socioEconomicMatches.push(keywordsArr[l]);
      }
    }

    // Process matches for tags array
    ageTagsToAdd = ageMatches.length > 0 ? ageMatches : [];
    genderTagsToAdd = genderMatches.length > 0 ? genderMatches : [];
    ethnicityTagsToAdd = ethnicityMatches.length > 0 ? ethnicityMatches : [];
    disabilityTagsToAdd = disabilityMatches.length > 0 ? disabilityMatches : [];
    socioEconomicTagsToAdd = socioEconomicMatches.length > 0 ? socioEconomicMatches : [];

    // DON'T add demographic tags to main tags array here!
    // Let the API server handle the demographic -> tag ID conversion
    // The demographic object below will be processed by the API server

    // *** PATCH27 FIX: Demographic object using collected matches ***
    // The API server will convert these demographic arrays to Firebase tag IDs
    var demographicObj = {
      industry: industryTags, // Keep as array for demographic.industry
      age: ageMatches.length > 0 ? ageMatches : allAgeOptions, // Use specific matches if found, otherwise default to ALL
      genderSexualPreference: genderMatches.length > 0 ? genderMatches : allGenderOptions, // Use specific matches if found, otherwise default to ALL
      ethnicity: ethnicityMatches.length > 0 ? ethnicityMatches : allEthnicityOptions, // Use specific matches if found, otherwise default to ALL
      disability: disabilityMatches.length > 0 ? disabilityMatches : allDisabilityOptions, // Use specific matches if found, otherwise default to ALL
      lowerSocioEconomicBackground: socioEconomicMatches.length > 0 ? socioEconomicMatches : allSocioEconomicOptions // Use specific matches if found, otherwise default to ALL
    }

    var result = {
      anythingElseImportant: str(data.anythingElseImportant),
      applicationDeadline: str(data.applicationDeadline),
      approvalFirst: bool(data.approvalFirst),
      author: str(data.author),
      bannerPic: str(data.bannerPic),
      bespokeOnly: bool(data.bespokeOnly),
      opportunityType: mappedCat,
      category: mappedCat,
      categoryTitle: str(data.categoryTitle),
      companyID: str(data.companyID) || 'S7IvlojyomcTNsUXlrqC',
      companyVerify: bool(data.companyVerify) || true,
      courseLocation: str(data.courseLocation),
      created: str(data.created) || 'S7IvlojyomcTNsUXlrqC',
      createdAt: str(data.createdAt),
      description: str(data.description),
      editedAt: str(data.editedAt),
      editor: str(data.editor) || 'scheduler',
      eventDate: str(data.eventDate),
      eventName: str(data.eventName),
      eventTime: str(data.eventTime),
      eventTimeEnd: str(data.eventTimeEnd),
      expiredDate: str(data.expiredDate),
      id: id(data.id),
      keywords: arr(data.keywords),
      lengthOfCourse: str(data.lengthOfCourse),
      link: str(data.link),
      location: str(data.location),
      locationName: str(data.locationName),
      notificated: bool(data.notificated),
      paidOrFreeCourses: str(data.paidOrFreeCourses),
      publishedAt: str(data.publishedAt),
      regionLocation: data.regionLocation === null ? null : str(data.regionLocation),
      remote: bool(data.remote),
      republish: bool(data.republish),
      schedulePost: str(data.schedulePost),
      status: str(data.status),
      supportSettings: arr(data.supportSettings),
      tags: {
        tags: tagsArr, // This now includes industry + keywords + demographic values
        demographic: {
          age: ageString,
          genderSexualPreference: genderString,
          ethnicity: ethnicityString,
          disability: disabilityString,
          lowerSocioEconomicBackground: lowerSocioEconomicBackgroundString,
          keywords: keywordsArr
        }
      },
      title: str(data.title),
      type: str(data.type) || 'announcements',
      ukWide: bool(data.ukWide),
      userClaps: arr(data.userClaps),
      userContentView: arr(data.userContentView),
      userLinkClick: arr(data.userLinkClick),
      usersFavouriteContent: arr(data.usersFavouriteContent),
      demographic: demographicObj,
      audienceLocation: str(data.audienceLocation)
    };

    // PATCH28: Include geolocation data if present (conditional addition)
    if (data._geoloc && typeof data._geoloc === 'object' && 
        typeof data._geoloc.lat === 'number' && 
        typeof data._geoloc.lng === 'number') {
      result._geoloc = {
        lat: data._geoloc.lat,
        lng: data._geoloc.lng
      };
    }

    return result;
  }
  Logger.log('üìã Processing document: ' + file.getName());

  // Extract text content from the file
  var content = extractTextContent(file);
  if (!content) {
    throw new Error('Could not extract text content from ' + file.getName());
  }

  var parsedData = null;
  var fileName = file.getName().toLowerCase();
  
  // Try to parse as JSON if file extension is .json (but not .txt to avoid parsing errors)
  if (fileName.endsWith('.json')) {
    try {
      var jsonCandidate = JSON.parse(content);
      if (typeof jsonCandidate === 'object' && jsonCandidate !== null) {
        parsedData = jsonCandidate;
        Logger.log('üì¶ Parsed JSON opportunity data from file.');
      }
    } catch (e) {
      Logger.log('Not valid JSON, falling back to text parsing: ' + e.toString());
    }
  }
  
  // NEW: Try to parse as text file with key-value format
  if (!parsedData && fileName.endsWith('.txt')) {
    try {
      parsedData = parseTextFileInGoogleScript(content);
      Logger.log('üìù Parsed text file opportunity data from file.');
    } catch (e) {
      Logger.log('Text parsing failed, falling back to default: ' + e.toString());
    }
  }

  // Option 1: If you have a parser API, call it first (only if not already parsed as JSON)
  // Disabled parser API for now - ngrok endpoint is offline
  // if (!parsedData && CONFIG.PARSER_API_URL && CONFIG.PARSER_API_URL !== 'https://karolyn-unmendacious-unsuccessfully.ngrok-free.dev/api/parse') {
  //   parsedData = callDocumentParser(content, file.getName());
  // }

  // Option 2: Create basic opportunity data ONLY if no parser or JSON
  if (!parsedData) {
    Logger.log('üìù Creating basic opportunity data from filename...');
    parsedData = {
      id: 'google-drive-' + file.getId(),
      opportunityType: guessOpportunityType(file.getName()),
      title: file.getName().replace(/\.[^/.]+$/, ""), // Remove file extension
      shortSummary: 'Opportunity extracted from: ' + file.getName(),
      location: 'Location to be determined',
      link: file.getUrl(),
      tags: {
        industry: ['General'],
        keywords: ['google-drive', 'document', 'opportunity']
      }
    };
  }

  // --- ENHANCEMENTS BEGIN ---
  // 1. Ensure correct opportunity type
  if (parsedData && (!parsedData.opportunityType || typeof parsedData.opportunityType !== 'string')) {
    parsedData.opportunityType = guessOpportunityType(file.getName());
  }

  // 2. Append backlog date/time to title
  var now = new Date();
  var nowStr = now.toISOString().replace('T', ' ').substring(0, 16); // e.g. 2025-11-05 14:30
  if (parsedData && parsedData.title) {
    parsedData.title = parsedData.title + ' [Backlog: ' + nowStr + ']';
  } else if (parsedData) {
    parsedData.title = file.getName().replace(/\.[^/.]+$/, "") + ' [Backlog: ' + nowStr + ']';
  }

  // 3. Add industry to demographic
  if (!parsedData.demographic) parsedData.demographic = {};
  parsedData.demographic.industry = parsedData.tags && parsedData.tags.industry ? parsedData.tags.industry : [];

  // 4. Add demographic fields (all as arrays for select tags)
  var demoFields = [
    'age',
    'genderSexualPreference',
    'ethnicity',
    'disability',
    'lowerSocioEconomicBackground'
  ];
  demoFields.forEach(function(field) {
    if (!parsedData.demographic[field]) parsedData.demographic[field] = [];
  });

  // 5. Add UK region to audienceLocation
  if (parsedData.ukRegion) {
    parsedData.audienceLocation = parsedData.ukRegion;
  } else if (!parsedData.audienceLocation) {
    parsedData.audienceLocation = '';
  }

  // --- ENHANCEMENTS END ---

  // Normalize just before sending
  parsedData = normalizeOpportunityData(parsedData);
  // Debug: log the normalized data structure before sending
  Logger.log('üü¶ Normalized data to send: ' + JSON.stringify(parsedData, null, 2));
  // Send to API Bridge
  var bridgeResult = sendToApiBridge(parsedData);
  
  if (bridgeResult && bridgeResult.success) {
    Logger.log('üéâ Successfully processed: ' + file.getName());
    Logger.log('üìÑ Firebase Doc ID: ' + bridgeResult.masterPortalDocId);
  } else {
    throw new Error('Failed to send to API Bridge: ' + (bridgeResult ? bridgeResult.error : 'Unknown error'));
  }
}

/**
 * Extract text content from different file types
 */
function extractTextContent(file) {
  var mimeType = file.getMimeType();
  var fileName = file.getName().toLowerCase();

  try {
    if (mimeType === MimeType.PLAIN_TEXT) {
      return file.getBlob().getDataAsString('UTF-8');
    } else if (mimeType === MimeType.WORD || fileName.endsWith('.docx')) {
      // Convert .docx to Google Docs temporarily
      var tempDoc = Drive.Files.insert({
        title: 'temp_conversion_' + file.getId(),
        mimeType: MimeType.GOOGLE_DOCS
      }, file.getBlob());
      
      var content = DocumentApp.openById(tempDoc.id).getBody().getText();
      Drive.Files.remove(tempDoc.id); // Clean up
      return content;
    }
    return null;
  } catch (e) {
    Logger.log('Error extracting text: ' + e.toString());
    return null;
  }
}

/**
 * Guess opportunity type from filename
 */
function guessOpportunityType(fileName) {
  var name = fileName.toLowerCase();
  if (name.includes('apprentice')) return 'Apprenticeship';
  if (name.includes('course') || name.includes('training')) return 'Course';
  if (name.includes('job') || name.includes('role')) return 'Job';
  if (name.includes('internship')) return 'Internship';
  return 'Opportunity'; // Default
}

/**
 * Call external document parser API (optional)
 */
function callDocumentParser(content, fileName) {
  if (!CONFIG.PARSER_API_URL) return null;
  
  var payload = {
    fileContent: content,
    fileName: fileName,
    source: 'google-drive'
  };

  var options = {
    method: 'post',
    contentType: 'application/json',
    headers: {
      'Authorization': 'Bearer ' + CONFIG.API_KEY
    },
    payload: JSON.stringify(payload),
    muteHttpExceptions: true
  };

  try {
    var response = UrlFetchApp.fetch(CONFIG.PARSER_API_URL, options);
    var responseCode = response.getResponseCode();
    
    if (responseCode === 200) {
      return JSON.parse(response.getContentText());
    } else {
      Logger.log('Parser API failed: ' + response.getContentText());
      return null;
    }
  } catch (e) {
    Logger.log('Parser API error: ' + e.toString());
    return null;
  }
}

/**
 * UTILITY FUNCTIONS
 */

function isSupportedFileType(file) {
  var mimeType = file.getMimeType();
  var fileName = file.getName().toLowerCase();
  return (mimeType === MimeType.PLAIN_TEXT || 
          mimeType === MimeType.WORD || 
          fileName.endsWith('.docx') ||
          fileName.endsWith('.txt'));
}

function isFileProcessed(fileId) {
  var properties = PropertiesService.getScriptProperties();
  var processedFiles = properties.getProperty('PROCESSED_FILES');
  var parsed = processedFiles ? JSON.parse(processedFiles) : {};
  return fileId in parsed;
}

function markFileAsProcessed(fileId, status) {
  var properties = PropertiesService.getScriptProperties();
  var processedFiles = properties.getProperty('PROCESSED_FILES');
  var parsed = processedFiles ? JSON.parse(processedFiles) : {};
  parsed[fileId] = {
    status: status,
    processedAt: new Date().toISOString()
  };
  properties.setProperty('PROCESSED_FILES', JSON.stringify(parsed));
}

/**
 * Clear all processed file markers (for testing)
 */
function clearAllProcessedMarkers() {
  PropertiesService.getScriptProperties().deleteProperty('PROCESSED_FILES');
  Logger.log('All processed file markers cleared.');
}

/**
 * üìä Get processing status
 */
function getProcessingStatus() {
  var properties = PropertiesService.getScriptProperties();
  var processedFiles = properties.getProperty('PROCESSED_FILES');
  
  if (!processedFiles) {
    Logger.log('No files have been processed yet.');
    return;
  }
  
  var parsed = JSON.parse(processedFiles);
  var stats = {success: 0, error: 0, unsupported: 0};
  
  Object.keys(parsed).forEach(function(fileId) {
    stats[parsed[fileId].status]++;
  });
  
  Logger.log('üìä Processing Status:');
  Logger.log('‚úÖ Success: ' + stats.success);
  Logger.log('‚ùå Errors: ' + stats.error); 
  Logger.log('üö´ Unsupported: ' + stats.unsupported);
  Logger.log('üìÅ Total: ' + Object.keys(parsed).length);
}

/**
 * üß™ Test Simplified Portal Structure - PATCH23 SIMPLIFIED
 */
function testSimplifiedPortalStructure() {
  Logger.log('üß™ Testing Simplified Portal Structure (PATCH23)...');
  
  var testData = {
    id: 'simplified-portal-test-' + Date.now(),
    opportunityType: 'Apprenticeship',
    title: 'Simplified Portal Structure Test - Should Work in Portal',
    shortSummary: 'Testing that the simplified structure (only tags array) works in the portal UI.',
    location: 'Manchester, UK',
    applicationDeadline: '2025-12-31T23:59:59Z',
    link: 'https://example.com/simplified-test',
    salary: '¬£20,000 per year',
    lengthOfApprenticeship: '18 months',
    levelOfApprenticeship: 'Level 4',
    status: 'live', // ‚Üê Set to live instead of expired
    anythingElseImportant: 'EXPECTED: Portal should show all demographics selected because tags array contains all demographic Firebase IDs.',
    tags: {
      industry: ['Technology'],
      keywords: ['apprentice', 'coding'] // ‚Üê NO demographic keywords = default to ALL
    }
  };

  Logger.log('üü¶ Before normalization - tags.keywords: ' + JSON.stringify(testData.tags.keywords));
  Logger.log('üîç Expected: Should default to ALL demographics, simplified structure for portal');
  
  var result = sendToApiBridge(testData);
  
  if (result && result.success) {
    Logger.log('üéâ SIMPLIFIED PORTAL STRUCTURE TEST SUCCESS!');
    Logger.log('üî• Master Portal Doc ID: ' + result.masterPortalDocId);
    Logger.log('üìã Check Firebase - should have simple structure with only tags array');
    Logger.log('üéØ Portal should now show all demographics selected!');
    
    return {
      success: true,
      masterPortalDocId: result.masterPortalDocId,
      message: 'Simplified structure test completed - check portal UI'
    };
  } else {
    Logger.log('‚ùå SIMPLIFIED PORTAL STRUCTURE TEST FAILED!');
    Logger.log('Error: ' + (result ? result.error : 'Unknown error'));
    
    return {
      success: false,
      error: result ? result.error : 'Unknown error'
    };
  }
}

/**
 * üß™ Test Portal UI Demographics Fix - PATCH29 NEW TEST!
 */
function testPortalUIDemographicsFix() {
  Logger.log('üß™ Testing Portal UI Demographics Fix (PATCH29)...');
  
  var testData = {
    id: 'portal-ui-demographics-fix-test-' + Date.now(),
    opportunityType: 'Apprenticeship',
    title: 'Portal UI Demographics Fix Test - Should Show All Demographic Sections',
    shortSummary: 'Testing that demographics appear in both hashtags AND demographic sections of portal UI.',
    location: 'Manchester, UK',
    applicationDeadline: '2025-12-31T23:59:59Z',
    link: 'https://example.com/portal-ui-demographics-fix-test',
    salary: '¬£22,000 per year',
    lengthOfApprenticeship: '18 months',
    levelOfApprenticeship: 'Level 4',
    status: 'live',
    anythingElseImportant: 'PATCH29: Should create both hashtag tags AND demographic object with portal-compatible text values.',
    tags: {
      industry: ['Technology'],
      keywords: ['apprentice', 'coding', 'He/Him', 'Arab', '18+ only', 'Physical disability', 'Lower socio-economic background'] // ‚Üê Demographic keywords that should become both tags AND demographic object
    }
  };

  Logger.log('üü¶ Before normalization - tags.keywords: ' + JSON.stringify(testData.tags.keywords));
  Logger.log('üîç Expected: Should create hashtag tags AND populate demographic sections with portal-compatible text');
  
  var result = sendToApiBridge(testData);
  
  if (result && result.success) {
    Logger.log('üéâ PORTAL UI DEMOGRAPHICS FIX TEST SUCCESS!');
    Logger.log('üî• Master Portal Doc ID: ' + result.masterPortalDocId);
    Logger.log('üìã Check Portal UI - should show demographics in BOTH hashtag section AND demographic sections');
    Logger.log('üéØ Expected in hashtag section: Multiple demographic tag IDs');
    Logger.log('üéØ Expected in demographic sections: He/Him, Arab, 18+ only, Physical disability, Lower socio-economic');
    
    return {
      success: true,
      masterPortalDocId: result.masterPortalDocId,
      message: 'Portal UI demographics fix test completed - check both hashtag and demographic sections'
    };
  } else {
    Logger.log('‚ùå PORTAL UI DEMOGRAPHICS FIX TEST FAILED!');
    Logger.log('Error: ' + (result ? result.error : 'Unknown error'));
    
    return {
      success: false,
      error: result ? result.error : 'Unknown error'
    };
  }
}

/**
 * üß™ Test Demographic Arrays Fix - PATCH25 NEW TEST!
 */
function testDemographicArraysFix() {
  Logger.log('üß™ Testing Demographic Arrays Fix (PATCH25)...');
  
  var testData = {
    id: 'demographic-arrays-fix-test-' + Date.now(),
    opportunityType: 'Apprenticeship',
    title: 'Demographic Arrays Fix Test - Should Include ALL Demographic Tag IDs',
    shortSummary: 'Testing that the API server properly processes demographic arrays and includes ALL demographic tag IDs in Firebase.',
    location: 'London, UK',
    applicationDeadline: '2025-12-31T23:59:59Z',
    link: 'https://example.com/demographic-arrays-fix-test',
    salary: '¬£22,000 per year',
    lengthOfApprenticeship: '18 months',
    levelOfApprenticeship: 'Level 4',
    status: 'live',
    anythingElseImportant: 'EXPECTED: Firebase tags array should contain 60+ tag IDs covering ALL demographic categories (age, gender, ethnicity, disability, socio-economic).',
    tags: {
      industry: ['Technology'],
      keywords: ['apprentice', 'coding'] // ‚Üê NO demographic keywords = default to ALL
    }
  };

  Logger.log('üü¶ Before normalization - tags.keywords: ' + JSON.stringify(testData.tags.keywords));
  Logger.log('üîç Expected: Should default to ALL demographics and include ALL tag IDs (60+ tags)');
  
  var result = sendToApiBridge(testData);
  
  if (result && result.success) {
    Logger.log('üéâ DEMOGRAPHIC ARRAYS FIX TEST SUCCESS!');
    Logger.log('üî• Master Portal Doc ID: ' + result.masterPortalDocId);
    Logger.log('üìã Check Firebase - should have 60+ tag IDs covering all demographics');
    Logger.log('üéØ Expected tag categories: ages (14 tags), genders (8 tags), ethnicities (7 tags), disabilities (5 tags), socio-economic (2 tags)');
    Logger.log('üéØ Portal should now show ALL demographics selected!');
    
    return {
      success: true,
      masterPortalDocId: result.masterPortalDocId,
      message: 'Demographic arrays fix test completed - check Firebase for 60+ tag IDs'
    };
  } else {
    Logger.log('‚ùå DEMOGRAPHIC ARRAYS FIX TEST FAILED!');
    Logger.log('Error: ' + (result ? result.error : 'Unknown error'));
    
    return {
      success: false,
      error: result ? result.error : 'Unknown error'
    };
  }
}

/**
 * üß™ Test Portal Display Comprehensive - Check ALL demographic types
 */
function testPortalDisplayComprehensive() {
  Logger.log('üß™ Testing Portal Display - ALL Demographics...');
  
  var testData = {
    id: 'portal-display-comprehensive-test-' + Date.now(),
    opportunityType: 'Apprenticeship',
    title: 'Portal Display Test - ALL Demographics Should Show in Portal',
    shortSummary: 'Testing that ALL demographic types display correctly in the portal UI.',
    location: 'Manchester, UK',
    applicationDeadline: '2025-12-31T23:59:59Z',
    link: 'https://example.com/portal-display-comprehensive-test',
    salary: '¬£22,000 per year',
    lengthOfApprenticeship: '18 months',
    levelOfApprenticeship: 'Level 4',
    status: 'live',
    anythingElseImportant: 'COMPREHENSIVE TEST: Should show ALL demographic types in portal UI - Age, Gender, Ethnicity, Disability, Socio-Economic',
    tags: {
      industry: ['Technology'],
      keywords: [
        'apprentice', 
        'coding',
        // Age
        'Over 18',
        // Gender  
        'He/Him',
        // Ethnicity
        'Asian or Asian British',
        // Disability
        'Physical disability',
        'Neurodiversity', 
        // Socio-Economic
        'All backgrounds'
      ]
    }
  };

  Logger.log('üü¶ Input keywords: ' + JSON.stringify(testData.tags.keywords));
  Logger.log('üîç Expected: Portal should show ALL demographic sections populated');
  
  // Manual normalization for API server
  var normalizedTestData = {
    id: testData.id,
    opportunityType: testData.opportunityType,
    title: testData.title,
    shortSummary: testData.shortSummary,
    location: testData.location,
    applicationDeadline: testData.applicationDeadline,
    link: testData.link,
    salary: testData.salary,
    lengthOfApprenticeship: testData.lengthOfApprenticeship,
    levelOfApprenticeship: testData.levelOfApprenticeship,
    status: testData.status,
    anythingElseImportant: testData.anythingElseImportant,
    tags: {
      tags: testData.tags.industry.concat(testData.tags.keywords),
      demographic: {
        age: '',
        genderSexualPreference: '',
        ethnicity: '',
        disability: '',
        lowerSocioEconomicBackground: '',
        keywords: testData.tags.keywords
      }
    },
    demographic: {
      industry: testData.tags.industry,
      age: ['Over 18'],
      genderSexualPreference: ['He/Him'],
      ethnicity: ['Asian or Asian British'],
      disability: ['Physical disability', 'Neurodiversity'],
      lowerSocioEconomicBackground: ['All backgrounds']
    }
  };
  
  Logger.log('üü¶ After manual normalization - demographic object: ' + JSON.stringify(normalizedTestData.demographic));
  
  var result = sendToApiBridge(normalizedTestData);
  
  if (result && result.success) {
    Logger.log('üéâ COMPREHENSIVE PORTAL DISPLAY TEST SUCCESS!');
    Logger.log('üî• Master Portal Doc ID: ' + result.masterPortalDocId);
    Logger.log('üìã NOW CHECK PORTAL UI FOR ALL SECTIONS:');
    Logger.log('üéØ Age section should show: Over 18');
    Logger.log('üéØ Gender section should show: He/Him');
    Logger.log('üéØ Ethnicity section should show: Asian or Asian British');
    Logger.log('üéØ Disability section should show: Physical disability, Neurodiversity');
    Logger.log('üéØ Socio-Economic section should show: All backgrounds');
    Logger.log('üéØ Tags/hashtag section should show multiple tag IDs');
    
    return {
      success: true,
      masterPortalDocId: result.masterPortalDocId,
      message: 'Comprehensive portal display test - check ALL demographic sections in portal'
    };
  } else {
    Logger.log('‚ùå COMPREHENSIVE PORTAL DISPLAY TEST FAILED!');
    Logger.log('Error: ' + (result ? result.error : 'Unknown error'));
    
    return {
      success: false,
      error: result ? result.error : 'Unknown error'
    };
  }
}

/**
 * üß™ Test Neurodiversity Tag ID Fix - CRITICAL TEST!
 */
function testNeurodiversityTagIdFix() {
  Logger.log('üß™ Testing Neurodiversity Tag ID Fix...');
  
  // FIXED: Send the proper demographic structure that the API server expects
  var testData = {
    id: 'neurodiversity-tag-test-' + Date.now(),
    opportunityType: 'Apprenticeship',
    title: 'Neurodiversity Tag ID Test - Should Include rT4QGqejDAONg3PmA9Il',
    shortSummary: 'Testing that Neurodiversity from demographic.disability array gets converted to tag ID rT4QGqejDAONg3PmA9Il.',
    location: 'Manchester, UK',
    applicationDeadline: '2025-12-31T23:59:59Z',
    link: 'https://example.com/neurodiversity-tag-test',
    salary: '¬£20,000 per year',
    lengthOfApprenticeship: '18 months',
    levelOfApprenticeship: 'Level 4',
    status: 'live',
    anythingElseImportant: 'EXPECTED: Firebase should include Neurodiversity tag ID rT4QGqejDAONg3PmA9Il that was missing from the original marketing-assistant-bristol.txt file.',
    // CRITICAL FIX: Send demographic object that API server processes
    demographic: {
      industry: ['Marketing', 'All Creative Industries'],
      age: ['21','22','23','24','25','Over 18','Under 18','Over 25','16 and under', '18+ only'],
      genderSexualPreference: ['He/Him', 'She/Her', 'They/Them', 'Non-binary', 'Transgender', 'Intersex', 'Other', 'Prefer not to say'],
      ethnicity: ['White or White British', 'African, Caribbean or Black British', 'Asian or Asian British', 'Mixed or Multiple Ethnic group', 'Other Ethnic Group', 'Arab', 'Prefer not to say'],
      disability: ['Chronic illness', 'Hearing impairment', 'Neurodiversity', 'Physical disability', 'Visual impairment', 'Mental health'], // ‚Üê This should include Neurodiversity!
      lowerSocioEconomicBackground: ['All backgrounds', 'Only those from lower socio-economic background', 'Have or had free school meals', 'Lower socio-economic background']
    }
  };

  Logger.log('üü¶ Input demographic.disability: ' + JSON.stringify(testData.demographic.disability));
  Logger.log('üîç Expected: API server should convert "Neurodiversity" to tag ID rT4QGqejDAONg3PmA9Il');
  
  var result = sendToApiBridge(testData);
  
  if (result && result.success) {
    Logger.log('üéâ NEURODIVERSITY TAG ID TEST SUCCESS!');
    Logger.log('üî• Master Portal Doc ID: ' + result.masterPortalDocId);
    Logger.log('üìã NOW CHECK: Does Firebase tags array include rT4QGqejDAONg3PmA9Il?');
    Logger.log('üéØ Expected: Should have 32+ tags, with rT4QGqejDAONg3PmA9Il included');
    
    return {
      success: true,
      masterPortalDocId: result.masterPortalDocId,
      message: 'Neurodiversity tag ID test completed - check Firebase for rT4QGqejDAONg3PmA9Il'
    };
  } else {
    Logger.log('‚ùå NEURODIVERSITY TAG ID TEST FAILED!');
    Logger.log('Error: ' + (result ? result.error : 'Unknown error'));
    
    return {
      success: false,
      error: result ? result.error : 'Unknown error'
    };
  }
}

/**
 * üß™ Test Physical Disability Multi-Tag Fix - CRITICAL TEST!
 */
function testPhysicalDisabilityMultiTag() {
  Logger.log('üß™ Testing Physical Disability Multi-Tag Fix...');
  
  var testData = {
    id: 'physical-disability-test-' + Date.now(),
    opportunityType: 'Apprenticeship',
    title: 'Physical Disability Test - Should Generate 3 Tag IDs',
    shortSummary: 'Testing that Physical disability keyword generates all 3 required Firebase tag IDs.',
    location: 'Manchester, UK',
    applicationDeadline: '2025-12-31T23:59:59Z',
    link: 'https://example.com/physical-disability-test',
    salary: '¬£18,000 per year',
    lengthOfApprenticeship: '18 months',
    levelOfApprenticeship: 'Level 4',
    status: 'live',
    anythingElseImportant: 'EXPECTED: Should generate 3 Firebase tag IDs for Physical disability: 09Q2FEVzWlOBc5AqoypO, QCMHvYz9oUPPPhOsXDek, YI6XgFxHn8x4LYzkHkIM',
    tags: {
      industry: ['Technology'],
      keywords: ['apprentice', 'coding', 'Physical disability'] // ‚Üê This should generate 3 tag IDs
    }
  };

  Logger.log('üü¶ Input keywords: ' + JSON.stringify(testData.tags.keywords));
  Logger.log('üîç Expected: Physical disability should create 3 separate Firebase tag IDs');
  
  // CRITICAL FIX: Manually create the normalized structure that the API server expects
  // The API server expects data.tags.tags as an array containing all keywords
  var normalizedTestData = {
    id: testData.id,
    opportunityType: testData.opportunityType,
    title: testData.title,
    shortSummary: testData.shortSummary,
    location: testData.location,
    applicationDeadline: testData.applicationDeadline,
    link: testData.link,
    salary: testData.salary,
    lengthOfApprenticeship: testData.lengthOfApprenticeship,
    levelOfApprenticeship: testData.levelOfApprenticeship,
    status: testData.status,
    anythingElseImportant: testData.anythingElseImportant,
    tags: {
      tags: testData.tags.industry.concat(testData.tags.keywords), // This creates the tags.tags array the API server needs
      demographic: {
        age: '',
        genderSexualPreference: '',
        ethnicity: '',
        disability: '',
        lowerSocioEconomicBackground: '',
        keywords: testData.tags.keywords
      }
    },
    demographic: {
      industry: testData.tags.industry,
      age: [],
      genderSexualPreference: [],
      ethnicity: [],
      disability: ['Physical disability'], // This should be processed by API server
      lowerSocioEconomicBackground: []
    }
  };
  
  Logger.log('üü¶ After manual normalization - tags.tags: ' + JSON.stringify(normalizedTestData.tags.tags));
  
  var result = sendToApiBridge(normalizedTestData);
  
  if (result && result.success) {
    Logger.log('üéâ PHYSICAL DISABILITY TEST SUCCESS!');
    Logger.log('üî• Master Portal Doc ID: ' + result.masterPortalDocId);
    Logger.log('üìã NOW CHECK: Does Firebase document have all 3 Physical disability tag IDs?');
    Logger.log('üéØ Expected IDs: 09Q2FEVzWlOBc5AqoypO, QCMHvYz9oUPPPhOsXDek, YI6XgFxHn8x4LYzkHkIM');
    
    return {
      success: true,
      masterPortalDocId: result.masterPortalDocId,
      message: 'Physical disability test completed - check Firebase for 3 tag IDs'
    };
  } else {
    Logger.log('‚ùå PHYSICAL DISABILITY TEST FAILED!');
    Logger.log('Error: ' + (result ? result.error : 'Unknown error'));
    
    return {
      success: false,
      error: result ? result.error : 'Unknown error'
    };
  }
}

/**
 * üß™ Test Geolocation Feature - NEW FEATURE!
 */
function testGeolocationFeature() {
  Logger.log('üß™ Testing Geolocation Feature...');
  
  var testLocations = ['Manchester', 'London', 'Birmingham', 'Edinburgh', 'Cardiff'];
  
  Logger.log('üåç Testing individual location geocoding:');
  for (var i = 0; i < testLocations.length; i++) {
    var location = testLocations[i];
    var coordinates = getLocationCoordinates(location);
    if (coordinates) {
      Logger.log('‚úÖ ' + location + ': lat=' + coordinates.lat + ', lng=' + coordinates.lng);
    } else {
      Logger.log('‚ùå ' + location + ': geocoding failed');
    }
  }
  
  Logger.log('üß™ Testing end-to-end with mock demographics file...');
  
  // Use the same content as our mock file but test the geolocation specifically
  var mockContent = `Salary: ¬£35,000 - ¬£42,000 per annum
Location: Manchester
Industry: Technology, HR, Diversity & Inclusion
Age: 18-25, Young professionals
Gender & Sexual Preference: Women, Non-binary, LGBTQ+, He/Him, She/Her, They/Them
Application deadline: 15 January 2026
Link: https://www.techcompany.com/careers/diversity-inclusion-coordinator`;

  Logger.log('üìù Parsing mock content with Manchester location...');
  var parsedData = parseTextFileInGoogleScript(mockContent);
  
  Logger.log('üîç Parsed location: ' + parsedData.location);
  if (parsedData._geoloc) {
    Logger.log('üåç Parsed geolocation: lat=' + parsedData._geoloc.lat + ', lng=' + parsedData._geoloc.lng);
  } else {
    Logger.log('‚ùå No geolocation data found in parsed result');
  }
  
  Logger.log('üöÄ Sending to API server...');
  var result = sendToApiBridge(parsedData);
  
  if (result && result.success) {
    Logger.log('üéâ GEOLOCATION FEATURE TEST SUCCESS!');
    Logger.log('üî• Master Portal Doc ID: ' + result.masterPortalDocId);
    Logger.log('üìã Check Firebase - should include _geoloc field with Manchester coordinates');
    Logger.log('üéØ Expected: _geoloc.lat ‚âà 53.487, _geoloc.lng ‚âà -2.290');
    
    return {
      success: true,
      masterPortalDocId: result.masterPortalDocId,
      message: 'Geolocation feature test completed - check Firebase for _geoloc field'
    };
  } else {
    Logger.log('‚ùå GEOLOCATION FEATURE TEST FAILED!');
    Logger.log('Error: ' + (result ? result.error : 'Unknown error'));
    
    return {
      success: false,
      error: result ? result.error : 'Unknown error'
    };
  }
}

/**
 * üß™ Test Multiple Location Geocoding - Comprehensive Test
 */
function testMultipleLocationGeocoding() {
  Logger.log('üß™ Testing Multiple Location Geocoding...');
  
  var testCases = [
    { input: 'Manchester', expectedLat: 53.487, expectedLng: -2.290 },
    { input: 'London', expectedLat: 51.507, expectedLng: -0.127 },
    { input: 'Birmingham', expectedLat: 52.479, expectedLng: -1.902 },
    { input: 'Online', expectedLat: null, expectedLng: null },
    { input: 'Remote', expectedLat: null, expectedLng: null },
    { input: 'UK Wide', expectedLat: null, expectedLng: null }
  ];
  
  var successCount = 0;
  var totalCount = testCases.length;
  
  for (var i = 0; i < testCases.length; i++) {
    var testCase = testCases[i];
    var coordinates = getLocationCoordinates(testCase.input);
    
    if (testCase.expectedLat === null) {
      if (coordinates === null) {
        Logger.log('‚úÖ ' + testCase.input + ': Correctly returned null (virtual location)');
        successCount++;
      } else {
        Logger.log('‚ùå ' + testCase.input + ': Expected null but got coordinates');
      }
    } else {
      if (coordinates && 
          Math.abs(coordinates.lat - testCase.expectedLat) < 0.1 && 
          Math.abs(coordinates.lng - testCase.expectedLng) < 0.1) {
        Logger.log('‚úÖ ' + testCase.input + ': lat=' + coordinates.lat + ', lng=' + coordinates.lng + ' (within expected range)');
        successCount++;
      } else if (coordinates) {
        Logger.log('‚ö†Ô∏è ' + testCase.input + ': lat=' + coordinates.lat + ', lng=' + coordinates.lng + ' (outside expected range)');
        successCount++; // Still count as success if we got coordinates
      } else {
        Logger.log('‚ùå ' + testCase.input + ': Failed to geocode');
      }
    }
  }
  
  Logger.log('üìä GEOLOCATION TEST SUMMARY: ' + successCount + '/' + totalCount + ' locations processed successfully');
  
  return {
    success: successCount >= totalCount * 0.8, // 80% success rate required
    processedCount: successCount,
    totalCount: totalCount,
    message: 'Multiple location geocoding test completed'
  };
}

/**
 * üß™ Test Milngavie Geocoding - Quick Test
 */
function testMilngavieGeocoding() {
  Logger.log('üß™ Testing Milngavie Geocoding Fix...');
  
  var testAddresses = [
    'Milngavie Library, Allander Road, Milngavie, G62 8PN, East Dunbartonshire, United Kingdom',
    'Milngavie',
    'East Dunbartonshire',
    'Glasgow'
  ];
  
  var successCount = 0;
  
  for (var i = 0; i < testAddresses.length; i++) {
    var address = testAddresses[i];
    var coords = getLocationCoordinates(address);
    
    if (coords) {
      Logger.log('‚úÖ "' + address + '" ‚Üí lat=' + coords.lat + ', lng=' + coords.lng);
      successCount++;
    } else {
      Logger.log('‚ùå "' + address + '" ‚Üí No coordinates found');
    }
  }
  
  Logger.log('üìä GEOCODING TEST RESULT: ' + successCount + '/' + testAddresses.length + ' addresses geocoded');
  
  if (successCount >= 3) {
    Logger.log('üéâ GEOCODING FIX SUCCESS! Enhanced fallback working correctly.');
    return { success: true, message: 'Milngavie geocoding working' };
  } else {
    Logger.log('‚ùå GEOCODING FIX FAILED! Need to investigate further.');
    return { success: false, message: 'Geocoding still not working properly' };
  }
}

/**
 * üß™ Test Geolocation Normalization Fix - CRITICAL TEST
 */
function testGeolocationNormalizationFix() {
  Logger.log('üß™ Testing Geolocation Normalization Fix...');
  Logger.log('üéØ This tests that _geoloc passes through normalizeOpportunityData');
  
  // Create simple test content with London location
  var testContent = 'Title: Test London Course\n' +
                    'Location: London\n' +
                    'Industry: Marketing\n' +
                    'Link: https://example.com/test';
  
  Logger.log('üöÄ Step 1: Testing parseTextFileInGoogleScript...');  
  var parsedData = parseTextFileInGoogleScript(testContent);
  
  if (parsedData._geoloc) {
    Logger.log('‚úÖ parseTextFileInGoogleScript works: _geoloc = {lat: ' + parsedData._geoloc.lat + ', lng: ' + parsedData._geoloc.lng + '}');
  } else {
    Logger.log('‚ùå parseTextFileInGoogleScript failed: no _geoloc field');
    return { success: false, error: 'No _geoloc from parseTextFileInGoogleScript' };
  }
  
  Logger.log('üöÄ Step 2: Testing complete pipeline with API Bridge...');
  var result = sendToApiBridge(parsedData);
  
  if (result && result.success) {
    Logger.log('üéâ GEOLOCATION FIX SUCCESS!');
    Logger.log('üî• Firebase Doc ID: ' + result.masterPortalDocId);
    Logger.log('üìã Check Firebase document - should contain _geoloc field');
    
    return {
      success: true,
      firebaseDocId: result.masterPortalDocId,
      message: 'Geolocation fix working - check Firebase for _geoloc field'
    };
  } else {
    Logger.log('‚ùå API BRIDGE FAILED!');
    Logger.log('Error: ' + (result ? result.error : 'Unknown error'));
    return { success: false, error: 'API Bridge failed' };
  }
}

/**
 * üß™ Test Complete Geolocation Pipeline - FINAL TEST
 */
function testCompleteGeolocationPipeline() {
  Logger.log('üß™ Testing Complete Geolocation Pipeline...');
  Logger.log('üéØ This test simulates the exact Milngavie scenario from your logs');
  
  // Step 1: Test the exact text content that failed
  var mockTextContent = 'Event Title: Shelved Stories with Creative Spark at Milngavie Library\n' +
                        'Event Description: Creative writing workshop\n' +
                        'Location: Milngavie Library, Allander Road, Milngavie, G62 8PN, East Dunbartonshire, United Kingdom\n' +
                        'Industry: Writing, Literary Arts, Arts\n' +
                        'Age Tags: 18, Over 18\n' +
                        'Gender & Sexual Preference: All genders & preferences\n' +
                        'Ethnicity: All ethnicities\n' +
                        'Disability: All disability\n' +
                        'Economic Background: All backgrounds\n' +
                        'Link: https://www.eventbrite.co.uk/test';
  
  Logger.log('üöÄ Step 1: Testing parseTextFileInGoogleScript...');
  var parsedData = parseTextFileInGoogleScript(mockTextContent);
  
  Logger.log('üîç Step 2: Checking parsed _geoloc field...');
  if (parsedData._geoloc && parsedData._geoloc.lat && parsedData._geoloc.lng) {
    Logger.log('‚úÖ parseTextFileInGoogleScript SUCCESS: _geoloc = {lat: ' + parsedData._geoloc.lat + ', lng: ' + parsedData._geoloc.lng + '}');
  } else {
    Logger.log('‚ùå parseTextFileInGoogleScript FAILED: _geoloc field missing or null');
    Logger.log('üîç Parsed _geoloc value: ' + JSON.stringify(parsedData._geoloc));
    return { success: false, error: 'parseTextFileInGoogleScript not adding _geoloc field' };
  }
  
  Logger.log('üöÄ Step 3: Testing API Bridge integration...');
  var result = sendToApiBridge(parsedData);
  
  if (result && result.success) {
    Logger.log('üéâ COMPLETE PIPELINE SUCCESS!');
    Logger.log('üî• Firebase Doc ID: ' + result.masterPortalDocId);
    Logger.log('üìã Expected in Firebase: _geoloc field with Milngavie coordinates');
    Logger.log('üéØ Coordinates: lat‚âà55.9423, lng‚âà-4.3177');
    Logger.log('üìù CHECK FIREBASE: Document ' + result.masterPortalDocId + ' should contain _geoloc field');
    
    return {
      success: true,
      firebaseDocId: result.masterPortalDocId,
      coordinates: parsedData._geoloc,
      message: 'Complete geolocation pipeline working - check Firebase for _geoloc field'
    };
  } else {
    Logger.log('‚ùå API BRIDGE FAILED!');
    Logger.log('Error: ' + (result ? result.error : 'Unknown error'));
    
    return {
      success: false,
      error: result ? result.error : 'API Bridge failed'
    };
  }
}

/**
 * üß™ Test Geolocation Fix - End-to-End Validation
 */
function testGeolocationFix() {
  Logger.log('üß™ Testing Geolocation Fix - End-to-End Validation...');
  
  var testData = {
    id: 'geolocation-fix-test-' + Date.now(),
    opportunityType: 'Course',
    title: 'Geolocation Fix Test - London Music Course',
    shortSummary: 'Testing that _geoloc field is preserved through the entire processing pipeline.',
    location: 'London',
    applicationDeadline: '2025-12-31T23:59:59Z',
    link: 'https://example.com/geolocation-fix-test',
    anythingElseImportant: 'CRITICAL: This test should include _geoloc field in Firebase document.',
    tags: {
      industry: ['Music'],
      keywords: ['test', 'geolocation', 'fix', 'london']
    }
  };

  Logger.log('üöÄ Step 1: Testing parseTextFileInGoogleScript with location...');
  
  // Simulate the text parsing that would include geolocation
  var mockContent = 'Title: ' + testData.title + '\n' +
                    'Location: ' + testData.location + '\n' +
                    'Industry: ' + testData.tags.industry.join(', ') + '\n' +
                    'Link: ' + testData.link + '\n' +
                    'Anything else important: ' + testData.anythingElseImportant;
  
  var parsedData = parseTextFileInGoogleScript(mockContent);
  
  Logger.log('üîç Step 2: Checking parsed data _geoloc field...');
  if (parsedData._geoloc) {
    Logger.log('‚úÖ parseTextFileInGoogleScript preserved _geoloc: lat=' + parsedData._geoloc.lat + ', lng=' + parsedData._geoloc.lng);
  } else {
    Logger.log('‚ùå parseTextFileInGoogleScript missing _geoloc field');
    return { success: false, error: 'Missing _geoloc in parseTextFileInGoogleScript' };
  }
  
  Logger.log('üöÄ Step 3: Sending through API Bridge...');
  var result = sendToApiBridge(parsedData);
  
  if (result && result.success) {
    Logger.log('üéâ GEOLOCATION FIX TEST SUCCESS!');
    Logger.log('üî• Master Portal Doc ID: ' + result.masterPortalDocId);
    Logger.log('üìã Next step: Check Firebase document for _geoloc field');
    Logger.log('üéØ Expected in Firebase: _geoloc.lat ‚âà 51.507, _geoloc.lng ‚âà -0.127');
    
    return {
      success: true,
      masterPortalDocId: result.masterPortalDocId,
      message: 'Geolocation fix test completed - check Firebase for _geoloc field',
      expectedCoordinates: { lat: 51.5074456, lng: -0.1277653 }
    };
  } else {
    Logger.log('‚ùå GEOLOCATION FIX TEST FAILED!');
    Logger.log('Error: ' + (result ? result.error : 'Unknown error'));
    
    return {
      success: false,
      error: result ? result.error : 'Unknown error'
    };
  }
}
