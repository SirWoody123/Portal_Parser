/**
 * ERIC API Bridge Integration - Complete Google Apps Script
 * 
 * SETUP INSTRUCTIONS:
 * 1. Deploy your API bridge to Railway/Heroku
  Logger.log('üìÅ Total: ' + Object.keys(parsed).length);
}
  }
  
  var parsed = JSON.parse(processedFiles);
  var stats = {success: 0, error: 0, unsupported: 0};
  
  Object.keys(parsed).forEach(function(fileId) {
    stats[parsed[fileId].status]++;
  });
  
  Logger.log('üìä Processing Status:');
  Logger.log('‚úÖ Success: ' + stats.success);
  Logger.log('‚ùå Errors: ' + stats.error); 
  Logger.log('üö´ Unsupported: ' + stats.unsupported);
  Logger.log('üìÅ Total: ' + Object.keys(parsed).length);
}
 * 4. Once working, run installTrigg
 * er() to set up automatic processing
 */

// --- CONFIGURATION ---
var CONFIG = {
  // UPDATE THIS WITH YOUR DEPLOYED API BRIDGE URL
  API_BRIDGE_URL: 'https://apibridge-production.up.railway.app/opportunities',
  
  // Your existing parser API (if you have one)
  PARSER_API_URL: 'https://karolyn-unmendacious-unsuccessively.ngrok-free.dev/api/parse',
  
  // Google Drive folder to monitor
  FOLDER_ID: '1NSsJLDQMYRiz-tX8LlN-ToNKBYRWV84F',
  
  // Other settings
  API_KEY: 'your-api-key-here',
  ERIC_WEBHOOK_URL: 'https://meet-eric.co/api/opportunities/review'
};

/**
 * üß™ TEST FUNCTION - Run this first to test your deployment
 */
function testApiBridgeIntegration() {
  Logger.log('üß™ Testing API Bridge Integration...');
  
  var testData = {
    id: 'google-apps-script-test-' + Date.now(),
    opportunityType: 'Apprenticeship',
    title: 'Software Developer Apprentice - Test',
    shortSummary: 'This is a test opportunity sent from Google Apps Script to verify the integration is working.',
    location: 'Manchester, UK',
    applicationDeadline: '2025-12-31T23:59:59Z',
    link: 'https://example.com/apply-test',
    salary: '¬£18,000 per year',
    lengthOfApprenticeship: '18 months',
    levelOfApprenticeship: 'Level 4',
    anythingElseImportant: 'This is a test from Google Apps Script integration.',
    tags: {
      industry: ['Technology', 'Software Development'],
      keywords: ['apprentice', 'coding', 'test', 'google-apps-script']
    }
  };

  var result = sendToApiBridge(testData);
  
  if (result && result.success) {
    Logger.log('‚úÖ SUCCESS! Integration is working!');
    Logger.log('üî• Master Portal Doc ID: ' + result.masterPortalDocId);
    Logger.log('üìÅ Collection Path: ' + result.collectionPath);
    Logger.log('üéâ Your Google Apps Script ‚Üí API Bridge ‚Üí Firebase integration is live!');
    
    // Test different opportunity types
    Logger.log('üîÑ Testing Course opportunity type...');
    testCourseOpportunity();
  } else {
    Logger.log('‚ùå FAILED! Check your API_BRIDGE_URL and deployment.');
    Logger.log('Error: ' + (result ? result.error : 'Unknown error'));
  }
}

/**
 * üöÄ RAILWAY TEST FUNCTION - Specifically for testing Railway deployment
 */
function testRailwayIntegration() {
  Logger.log('üöÄ Testing Railway Integration...');
  Logger.log('üîó Railway URL: ' + CONFIG.API_BRIDGE_URL);
  
  var testData = {
    id: 'railway-google-apps-script-test-' + Date.now(),
    opportunityType: 'Apprenticeship',
    title: 'Railway Integration Test - Software Developer Apprentice',
    shortSummary: 'Testing the complete Railway ‚Üí API Bridge ‚Üí Firebase integration from Google Apps Script.',
    location: 'London, UK',
    applicationDeadline: '2025-12-31T23:59:59Z',
    link: 'https://example.com/apply-railway-test',
    salary: '¬£22,000 per year',
    lengthOfApprenticeship: '24 months',
    levelOfApprenticeship: 'Level 4',
    anythingElseImportant: 'This is a Railway deployment test from Google Apps Script.',
    tags: {
      industry: ['Technology', 'Software Development', 'Railway'],
      keywords: ['apprentice', 'railway', 'deployment', 'integration', 'test']
    }
  };

  var result = sendToApiBridge(testData);
  
  if (result && result.success) {
    Logger.log('üéâ RAILWAY SUCCESS! Integration is working perfectly!');
    Logger.log('üî• Master Portal Doc ID: ' + result.masterPortalDocId);
    Logger.log('üìÅ Collection Path: ' + result.collectionPath);
    Logger.log('üöÄ Railway URL: https://apibridge-production.up.railway.app');
    Logger.log('‚úÖ Your complete integration is live: Google Apps Script ‚Üí Railway ‚Üí Firebase!');
    
    return {
      success: true,
      masterPortalDocId: result.masterPortalDocId,
      railwayUrl: 'https://apibridge-production.up.railway.app'
    };
  } else {
    Logger.log('‚ùå RAILWAY TEST FAILED!');
    Logger.log('üîó URL: ' + CONFIG.API_BRIDGE_URL);
    Logger.log('Error: ' + (result ? result.error : 'Unknown error'));
    
    return {
      success: false,
      error: result ? result.error : 'Unknown error'
    };
  }
}

/**
 * üß™ Test Course Opportunity Type
 */
function testCourseOpportunity() {
  var courseData = {
    id: 'google-apps-script-course-test-' + Date.now(),
    opportunityType: 'Course',
    title: 'Full Stack Web Development Bootcamp - Test',
    shortSummary: 'Intensive bootcamp covering modern web development technologies.',
    location: 'Online',
    applicationDeadline: '2025-11-15T23:59:59Z',
    link: 'https://example.com/bootcamp-test',
    lengthOfCourse: '12 weeks',
    courseType: 'Paid',
    anythingElseImportant: 'Evening classes available. Portfolio projects included.',
    tags: {
      industry: ['Technology', 'Web Development', 'Education'],
      keywords: ['bootcamp', 'javascript', 'react', 'nodejs', 'full-stack']
    }
  };

  var result = sendToApiBridge(courseData);
  
  if (result && result.success) {
    Logger.log('‚úÖ Course test SUCCESS! Doc ID: ' + result.masterPortalDocId);
  } else {
    Logger.log('‚ùå Course test FAILED: ' + (result ? result.error : 'Unknown error'));
  }
}

/**
 * üß™ Test Demographics Integration - CRITICAL TEST!
 */
function testDemographicsIntegration() {
  Logger.log('üß™ Testing Demographics Integration...');
  
  var testData = {
    id: 'demographics-test-' + Date.now(),
    opportunityType: 'Apprenticeship',
    title: 'Demographics Test - Software Developer Apprentice',
    shortSummary: 'Testing demographic tag integration from Google Apps Script.',
    location: 'Manchester, UK',
    applicationDeadline: '2025-12-31T23:59:59Z',
    link: 'https://example.com/apply-demographics-test',
    salary: '¬£18,000 per year',
    lengthOfApprenticeship: '18 months',
    levelOfApprenticeship: 'Level 4',
    anythingElseImportant: 'CRITICAL: This test includes demographic keywords that should appear as Firebase tag IDs.',
    tags: {
      industry: ['Technology', 'Software Development'],
      keywords: ['apprentice', 'coding', 'He/Him', 'Asian', 'Over 18', 'Neurodiversity']  // ‚Üê Fixed demographics!
    }
  };

  // This will go through normalizeOpportunityData and should populate tagsArr
  Logger.log('üü¶ Before normalization - tags.keywords: ' + JSON.stringify(testData.tags.keywords));
  
  var result = sendToApiBridge(testData);
  
  if (result && result.success) {
    Logger.log('üéâ DEMOGRAPHICS TEST SUCCESS!');
    Logger.log('üî• Master Portal Doc ID: ' + result.masterPortalDocId);
    Logger.log('üìã Check Firebase - should contain tag IDs for: He/Him, Asian, Over 18, Neurodiversity');
    
    return {
      success: true,
      masterPortalDocId: result.masterPortalDocId,
      message: 'Demographics test completed - check Firebase for populated tags'
    };
  } else {
    Logger.log('‚ùå DEMOGRAPHICS TEST FAILED!');
    Logger.log('Error: ' + (result ? result.error : 'Unknown error'));
    
    return {
      success: false,
      error: result ? result.error : 'Unknown error'
    };
  }
}

/**
 * üì§ Send data to API Bridge (your deployed service)
 */
function sendToApiBridge(opportunityData) {
  Logger.log('üì§ Sending to API Bridge: ' + opportunityData.title);
  
  var options = {
    method: 'post',
    contentType: 'application/json',
    payload: JSON.stringify(opportunityData),
    muteHttpExceptions: true
  };

  try {
    var response = UrlFetchApp.fetch(CONFIG.API_BRIDGE_URL, options);
    var responseCode = response.getResponseCode();
    var responseBody = response.getContentText();

    Logger.log('üì° API Bridge Response Code: ' + responseCode);

    if (responseCode === 200) {
      var result = JSON.parse(responseBody);
      Logger.log('‚úÖ API Bridge Success: ' + JSON.stringify(result, null, 2));
      return {
        success: true,
        masterPortalDocId: result.masterPortalDocId,
        collectionPath: result.collectionPath,
        data: result.data
      };
    } else {
      Logger.log('‚ùå API Bridge Error: ' + responseBody);
      return {
        success: false,
        error: 'HTTP ' + responseCode + ': ' + responseBody
      };
    }
  } catch (error) {
    Logger.log('‚ùå Network Error: ' + error.toString());
    return {
      success: false,
      error: 'Network Error: ' + error.toString()
    };
  }
}

/**
 * üîß PRODUCTION FUNCTIONS - Use these once testing works
 */

/**
 * Install trigger to monitor Google Drive folder
 */
function installTrigger() {
  // Delete any existing triggers
  var triggers = ScriptApp.getProjectTriggers();
  triggers.forEach(function(trigger) {
    if (trigger.getHandlerFunction() === 'checkFilesAndProcess') {
      ScriptApp.deleteTrigger(trigger);
    }
  });
  
  // Create new trigger (runs every 12 Hours)
  ScriptApp.newTrigger('checkFilesAndProcess')
    .timeBased()
    .everyHours(12)
    .create();
    
  Logger.log('‚úÖ Trigger installed! Will check for new files every 12 Hours.');
}

/**
 * Main function that processes files from Google Drive
 */
function checkFilesAndProcess() {
  try {
    Logger.log('üîç Checking for new files in Google Drive folder...');
    
    var folder = DriveApp.getFolderById(CONFIG.FOLDER_ID);
    var files = folder.getFiles();
    var processedCount = 0;
    
    while (files.hasNext()) {
      var file = files.next();
      
      if (isFileProcessed(file.getId())) {
        continue; // Skip already processed files
      }

      if (isSupportedFileType(file)) {
        try {
          Logger.log('üìÑ Processing: ' + file.getName());
          processDocument(file);
          markFileAsProcessed(file.getId(), 'success');
          processedCount++;
        } catch (e) {
          Logger.log('‚ùå Error processing ' + file.getName() + ': ' + e.toString());
          markFileAsProcessed(file.getId(), 'error');
        }
      } else {
        markFileAsProcessed(file.getId(), 'unsupported');
      }
    }
    
    if (processedCount > 0) {
      Logger.log('‚úÖ Processed ' + processedCount + ' new files.');
    } else {
      Logger.log('‚ÑπÔ∏è No new files to process.');
    }
  } catch (e) {
    Logger.log('‚ùå Fatal error in checkFilesAndProcess: ' + e.toString());
  }
}

/**
 * Process a single document file
 */
function processDocument(file) {
  // --- NORMALIZATION FUNCTION ---
  function normalizeOpportunityData(data) {
    // Helper functions
    function arr(val) { return Array.isArray(val) ? val : (val ? [val] : []); }
    function str(val) { return typeof val === 'string' ? val : ''; }
    function bool(val) { return typeof val === 'boolean' ? val : false; }
    function strOrNull(val) { return val === null ? null : str(val); }
    function id(val) { return typeof val === 'string' ? val : (val ? String(val) : ''); }

    // Allowed categories: label and value (frontend expects value)
    var allowedCategories = [
      { label: 'Apprenticeship', name: 'apprenticeship' },
      { label: 'Competition/Grant', name: 'competition-grant' },
      { label: 'Course', name: 'course' },
      { label: 'Freelance role', name: 'freelance-role' },
      { label: 'Internship', name: 'internship' },
      { label: 'Junior full-time role', name: 'junior-full-time-role' },
      { label: 'Junior part-time role', name: 'junior-part-time-role' },
      { label: 'Mentoring', name: 'mentoring' },
      { label: 'Opportunity', name: 'opportunity' },
      { label: 'Runner role', name: 'runner-role' },
      { label: 'Training scheme', name: 'training-scheme' },
      { label: 'Work experience', name: 'work-experience' }
    ];

    // Find best match for category (label or value)
    function mapCategory(val) {
      var v = str(val).trim();
      if (!v) return '';
      // Try label match (case-insensitive)
      var found = allowedCategories.find(function(opt) { return opt.label.toLowerCase() === v.toLowerCase(); });
      if (found) return found.name;
      // Try value match (case-insensitive)
      found = allowedCategories.find(function(opt) { return opt.name.toLowerCase() === v.toLowerCase(); });
      if (found) return found.name;
      return '';
    }

    var rawCat = str(data.category) || str(data.opportunityType);
    var mappedCat = mapCategory(rawCat);
    
    // Only if not matched, try to infer from filename or tags
    if (!mappedCat) {
      var title = str(data.title).toLowerCase();
      var idVal = str(data.id).toLowerCase();
      var keywords = [];
      if (Array.isArray(data.tags)) {
        data.tags.forEach(function(tagObj) {
          if (tagObj && Array.isArray(tagObj.keywords)) {
            keywords = keywords.concat(tagObj.keywords.map(function(k){return String(k).toLowerCase();}));
          }
        });
      }
      if (title.includes('apprentice') || idVal.includes('apprentice') || keywords.includes('apprentice')) mappedCat = 'apprenticeship';
      else if (title.includes('intern') || idVal.includes('intern') || keywords.includes('intern')) mappedCat = 'internship';
      else if (title.includes('course') || idVal.includes('course') || keywords.includes('course')) mappedCat = 'course';
      else if (title.includes('training') || idVal.includes('training') || keywords.includes('training')) mappedCat = 'training-scheme';
      else if (title.includes('runner') || idVal.includes('runner') || keywords.includes('runner')) mappedCat = 'runner-role';
      else if (title.includes('freelance') || idVal.includes('freelance') || keywords.includes('freelance')) mappedCat = 'freelance-role';
      else if (title.includes('competition') || idVal.includes('competition') || keywords.includes('competition') || title.includes('grant') || idVal.includes('grant') || keywords.includes('grant')) mappedCat = 'competition-grant';
      else if (title.includes('junior') && title.includes('full') && title.includes('time')) mappedCat = 'junior-full-time-role';
      else if (title.includes('junior') && title.includes('part') && title.includes('time')) mappedCat = 'junior-part-time-role';
      else if (title.includes('mentor') || idVal.includes('mentor') || keywords.includes('mentor')) mappedCat = 'mentoring';
      else if (title.includes('work experience') || idVal.includes('work experience') || keywords.includes('work experience')) mappedCat = 'work-experience';
      else if (title.includes('job') || idVal.includes('job') || keywords.includes('job')) mappedCat = 'junior-full-time-role';
      else mappedCat = 'opportunity';
    }

    // Allowed industries (case-insensitive match)
    var allowedIndustries = [
      'All Creative Industries', 'Acting', 'Advertising', 'Animation', 'Architecture', 'Arts', 'Audio', 'Comedy', 'Content Creation', 'Craft', 'Culture', 'Dance', 'Design', 'Digital', 'Directing', 'E-Sport', 'Fashion', 'Film', 'Gaming', 'Graphic Design', 'Heritage', 'Journalism', 'Marketing', 'Media', 'Museum', 'Music', 'Performing Arts', 'Photography', 'Podcasting', 'PR', 'Presenting', 'Publishing', 'Radio', 'Social Media', 'Theatre', 'TV', 'UX/UI Design', 'VFX', 'Videography', 'Visual Art', 'Writing'
    ];

    // Normalize industry tags: always array, only allowed values, case-insensitive
    function normalizeIndustries(input) {
      var arrInput = Array.isArray(input) ? input : (input ? [input] : []);
      return arrInput
        .map(function(val) { return String(val).trim(); })
        .filter(function(val) {
          return allowedIndustries.some(function(ai) { return ai.toLowerCase() === val.toLowerCase(); });
        })
        .map(function(val) {
          // Return the canonical casing from allowedIndustries
          var found = allowedIndustries.find(function(ai) { return ai.toLowerCase() === val.toLowerCase(); });
          return found || val;
        });
    }

    // Extract industry tags from data.tags.industry or data.industry
    var industryTags = [];
    if (data.tags && Array.isArray(data.tags.industry)) {
      industryTags = normalizeIndustries(data.tags.industry);
    } else if (Array.isArray(data.industry)) {
      industryTags = normalizeIndustries(data.industry);
    }
    if (!industryTags) industryTags = [];

    // Extract keywords from data.tags.keywords or data.keywords
    var keywordsArr = [];
    if (data.tags && Array.isArray(data.tags.keywords)) {
      keywordsArr = data.tags.keywords.map(function(k) { return String(k); });
    } else if (Array.isArray(data.keywords)) {
      keywordsArr = data.keywords.map(function(k) { return String(k); });
    }
    if (!keywordsArr) keywordsArr = [];

    // *** FIX: Build tagsArr to include ALL tags (industry + keywords + demographic values) ***
    var tagsArr = [];
    
    // Add industry tags
    tagsArr = tagsArr.concat(industryTags);
    
    // Add keyword tags
    tagsArr = tagsArr.concat(keywordsArr);

    // Define allowed demographic values (updated based on UI feedback)
    var allowedAges = ['21','22','23','24','25','Over 18','Under 18','Over 25','16 and under'];
    var allowedGenders = ['All genders & preferences', 'He/Him', 'She/Her', 'They/Them', 'Non-binary', 'Transgender', 'Intersex', 'Other', 'Prefer not to say'];
    var allowedEthnicities = ['All ethnicities', 'White', 'Black', 'Asian', 'Mixed', 'Other', 'Prefer not to say'];
    var allowedDisabilities = ['All disability', 'Chronic illness', 'Hearing impairment', 'Neurodiversity', 'Physical disability', 'Visual impairment'];
    var allowedSocioEconomic = ['20fXkU9RdlTlpfcS5K5D', 'V9J6aDjeQc7hIePqgsCh'];

    // Extract demographic values and add them to tagsArr
    var ageString = '';
    var genderString = 'All genders & preferences';
    var ethnicityString = 'All ethnicities';
    var disabilityString = '';
    var lowerSocioEconomicBackgroundString = '';

    // Find age in keywords and add to tagsArr
    for (var i = 0; i < keywordsArr.length; i++) {
      if (allowedAges.includes(keywordsArr[i])) {
        ageString = keywordsArr[i];
        if (tagsArr.indexOf(ageString) === -1) tagsArr.push(ageString);
        break;
      }
    }

    // Find gender in keywords and add to tagsArr
    for (var j = 0; j < keywordsArr.length; j++) {
      if (allowedGenders.includes(keywordsArr[j])) {
        genderString = keywordsArr[j];
        if (tagsArr.indexOf(genderString) === -1) tagsArr.push(genderString);
        break;
      }
    }

    // Find ethnicity in keywords and add to tagsArr
    for (var k = 0; k < keywordsArr.length; k++) {
      if (allowedEthnicities.includes(keywordsArr[k])) {
        ethnicityString = keywordsArr[k];
        if (tagsArr.indexOf(ethnicityString) === -1) tagsArr.push(ethnicityString);
        break;
      }
    }

    // Find disability in keywords and add to tagsArr
    for (var d = 0; d < keywordsArr.length; d++) {
      if (allowedDisabilities.includes(keywordsArr[d])) {
        disabilityString = keywordsArr[d];
        if (tagsArr.indexOf(disabilityString) === -1) tagsArr.push(disabilityString);
        break;
      }
    }

    // Find socioeconomic in keywords and add to tagsArr
    for (var l = 0; l < keywordsArr.length; l++) {
      if (allowedSocioEconomic.includes(keywordsArr[l])) {
        lowerSocioEconomicBackgroundString = keywordsArr[l];
        if (tagsArr.indexOf(lowerSocioEconomicBackgroundString) === -1) tagsArr.push(lowerSocioEconomicBackgroundString);
        break;
      }
    }

    // *** FIX: Create the demographic object structure that matches our working sample ***
    var demographicObj = {
      industry: industryTags, // Keep as array for demographic.industry
      age: [], // Keep as empty arrays as shown in your logs
      genderSexualPreference: [],
      ethnicity: [],
      disability: [],
      lowerSocioEconomicBackground: []
    }

    return {
      anythingElseImportant: str(data.anythingElseImportant),
      applicationDeadline: str(data.applicationDeadline),
      approvalFirst: bool(data.approvalFirst),
      author: str(data.author),
      bannerPic: str(data.bannerPic),
      bespokeOnly: bool(data.bespokeOnly),
      opportunityType: mappedCat,
      category: mappedCat,
      categoryTitle: str(data.categoryTitle),
      companyID: str(data.companyID) || 'S7IvlojyomcTNsUXlrqC',
      companyVerify: bool(data.companyVerify) || true,
      courseLocation: str(data.courseLocation),
      created: str(data.created) || 'S7IvlojyomcTNsUXlrqC',
      createdAt: str(data.createdAt),
      description: str(data.description),
      editedAt: str(data.editedAt),
      editor: str(data.editor) || 'scheduler',
      eventDate: str(data.eventDate),
      eventName: str(data.eventName),
      eventTime: str(data.eventTime),
      eventTimeEnd: str(data.eventTimeEnd),
      expiredDate: str(data.expiredDate),
      id: id(data.id),
      keywords: arr(data.keywords),
      lengthOfCourse: str(data.lengthOfCourse),
      link: str(data.link),
      location: str(data.location),
      locationName: str(data.locationName),
      notificated: bool(data.notificated),
      paidOrFreeCourses: str(data.paidOrFreeCourses),
      publishedAt: str(data.publishedAt),
      regionLocation: data.regionLocation === null ? null : str(data.regionLocation),
      remote: bool(data.remote),
      republish: bool(data.republish),
      schedulePost: str(data.schedulePost),
      status: str(data.status),
      supportSettings: arr(data.supportSettings),
      tags: {
        tags: tagsArr, // This now includes industry + keywords + demographic values
        demographic: {
          age: ageString,
          genderSexualPreference: genderString,
          ethnicity: ethnicityString,
          disability: disabilityString,
          lowerSocioEconomicBackground: lowerSocioEconomicBackgroundString,
          keywords: keywordsArr
        }
      },
      title: str(data.title),
      type: str(data.type) || 'announcements',
      ukWide: bool(data.ukWide),
      userClaps: arr(data.userClaps),
      userContentView: arr(data.userContentView),
      userLinkClick: arr(data.userLinkClick),
      usersFavouriteContent: arr(data.usersFavouriteContent),
      demographic: demographicObj,
      audienceLocation: str(data.audienceLocation)
    };
  }
  Logger.log('üìã Processing document: ' + file.getName());

  // Extract text content from the file
  var content = extractTextContent(file);
  if (!content) {
    throw new Error('Could not extract text content from ' + file.getName());
  }

  var parsedData = null;
  var fileName = file.getName().toLowerCase();
  // Try to parse as JSON if file extension is .json or .txt, or if content looks like JSON
  if (fileName.endsWith('.json') || fileName.endsWith('.txt')) {
    try {
      var jsonCandidate = JSON.parse(content);
      if (typeof jsonCandidate === 'object' && jsonCandidate !== null) {
        parsedData = jsonCandidate;
        Logger.log('üì¶ Parsed JSON opportunity data from file.');
      }
    } catch (e) {
      Logger.log('Not valid JSON, falling back to default: ' + e.toString());
    }
  }

  // Option 1: If you have a parser API, call it first (only if not already parsed as JSON)
  if (!parsedData && CONFIG.PARSER_API_URL && CONFIG.PARSER_API_URL !== 'https://karolyn-unmendacious-unsuccessfully.ngrok-free.dev/api/parse') {
    parsedData = callDocumentParser(content, file.getName());
  }

  // Option 2: Create basic opportunity data ONLY if no parser or JSON
  if (!parsedData) {
    Logger.log('üìù Creating basic opportunity data from filename...');
    parsedData = {
      id: 'google-drive-' + file.getId(),
      opportunityType: guessOpportunityType(file.getName()),
      title: file.getName().replace(/\.[^/.]+$/, ""), // Remove file extension
      shortSummary: 'Opportunity extracted from: ' + file.getName(),
      location: 'Location to be determined',
      link: file.getUrl(),
      tags: {
        industry: ['General'],
        keywords: ['google-drive', 'document', 'opportunity']
      }
    };
  }

  // --- ENHANCEMENTS BEGIN ---
  // 1. Ensure correct opportunity type
  if (parsedData && (!parsedData.opportunityType || typeof parsedData.opportunityType !== 'string')) {
    parsedData.opportunityType = guessOpportunityType(file.getName());
  }

  // 2. Append backlog date/time to title
  var now = new Date();
  var nowStr = now.toISOString().replace('T', ' ').substring(0, 16); // e.g. 2025-11-05 14:30
  if (parsedData && parsedData.title) {
    parsedData.title = parsedData.title + ' [Backlog: ' + nowStr + ']';
  } else if (parsedData) {
    parsedData.title = file.getName().replace(/\.[^/.]+$/, "") + ' [Backlog: ' + nowStr + ']';
  }

  // 3. Add industry to demographic
  if (!parsedData.demographic) parsedData.demographic = {};
  parsedData.demographic.industry = parsedData.tags && parsedData.tags.industry ? parsedData.tags.industry : [];

  // 4. Add demographic fields (all as arrays for select tags)
  var demoFields = [
    'age',
    'genderSexualPreference',
    'ethnicity',
    'disability',
    'lowerSocioEconomicBackground'
  ];
  demoFields.forEach(function(field) {
    if (!parsedData.demographic[field]) parsedData.demographic[field] = [];
  });

  // 5. Add UK region to audienceLocation
  if (parsedData.ukRegion) {
    parsedData.audienceLocation = parsedData.ukRegion;
  } else if (!parsedData.audienceLocation) {
    parsedData.audienceLocation = '';
  }

  // --- ENHANCEMENTS END ---

  // Normalize just before sending
  parsedData = normalizeOpportunityData(parsedData);
  // Debug: log the normalized data structure before sending
  Logger.log('üü¶ Normalized data to send: ' + JSON.stringify(parsedData, null, 2));
  // Send to API Bridge
  var bridgeResult = sendToApiBridge(parsedData);
  
  if (bridgeResult && bridgeResult.success) {
    Logger.log('üéâ Successfully processed: ' + file.getName());
    Logger.log('üìÑ Firebase Doc ID: ' + bridgeResult.masterPortalDocId);
  } else {
    throw new Error('Failed to send to API Bridge: ' + (bridgeResult ? bridgeResult.error : 'Unknown error'));
  }
}

/**
 * Extract text content from different file types
 */
function extractTextContent(file) {
  var mimeType = file.getMimeType();
  var fileName = file.getName().toLowerCase();

  try {
    if (mimeType === MimeType.PLAIN_TEXT) {
      return file.getBlob().getDataAsString('UTF-8');
    } else if (mimeType === MimeType.WORD || fileName.endsWith('.docx')) {
      // Convert .docx to Google Docs temporarily
      var tempDoc = Drive.Files.insert({
        title: 'temp_conversion_' + file.getId(),
        mimeType: MimeType.GOOGLE_DOCS
      }, file.getBlob());
      
      var content = DocumentApp.openById(tempDoc.id).getBody().getText();
      Drive.Files.remove(tempDoc.id); // Clean up
      return content;
    }
    return null;
  } catch (e) {
    Logger.log('Error extracting text: ' + e.toString());
    return null;
  }
}

/**
 * Guess opportunity type from filename
 */
function guessOpportunityType(fileName) {
  var name = fileName.toLowerCase();
  if (name.includes('apprentice')) return 'Apprenticeship';
  if (name.includes('course') || name.includes('training')) return 'Course';
  if (name.includes('job') || name.includes('role')) return 'Job';
  if (name.includes('internship')) return 'Internship';
  return 'Opportunity'; // Default
}

/**
 * Call external document parser API (optional)
 */
function callDocumentParser(content, fileName) {
  if (!CONFIG.PARSER_API_URL) return null;
  
  var payload = {
    fileContent: content,
    fileName: fileName,
    source: 'google-drive'
  };

  var options = {
    method: 'post',
    contentType: 'application/json',
    headers: {
      'Authorization': 'Bearer ' + CONFIG.API_KEY
    },
    payload: JSON.stringify(payload),
    muteHttpExceptions: true
  };

  try {
    var response = UrlFetchApp.fetch(CONFIG.PARSER_API_URL, options);
    var responseCode = response.getResponseCode();
    
    if (responseCode === 200) {
      return JSON.parse(response.getContentText());
    } else {
      Logger.log('Parser API failed: ' + response.getContentText());
      return null;
    }
  } catch (e) {
    Logger.log('Parser API error: ' + e.toString());
    return null;
  }
}

/**
 * UTILITY FUNCTIONS
 */

function isSupportedFileType(file) {
  var mimeType = file.getMimeType();
  var fileName = file.getName().toLowerCase();
  return (mimeType === MimeType.PLAIN_TEXT || 
          mimeType === MimeType.WORD || 
          fileName.endsWith('.docx') ||
          fileName.endsWith('.txt'));
}

function isFileProcessed(fileId) {
  var properties = PropertiesService.getScriptProperties();
  var processedFiles = properties.getProperty('PROCESSED_FILES');
  var parsed = processedFiles ? JSON.parse(processedFiles) : {};
  return fileId in parsed;
}

function markFileAsProcessed(fileId, status) {
  var properties = PropertiesService.getScriptProperties();
  var processedFiles = properties.getProperty('PROCESSED_FILES');
  var parsed = processedFiles ? JSON.parse(processedFiles) : {};
  parsed[fileId] = {
    status: status,
    processedAt: new Date().toISOString()
  };
  properties.setProperty('PROCESSED_FILES', JSON.stringify(parsed));
}

/**
 * Clear all processed file markers (for testing)
 */
function clearAllProcessedMarkers() {
  PropertiesService.getScriptProperties().deleteProperty('PROCESSED_FILES');
  Logger.log('All processed file markers cleared.');
}

/**
 * üìä Get processing status
 */
function getProcessingStatus() {
  var properties = PropertiesService.getScriptProperties();
  var processedFiles = properties.getProperty('PROCESSED_FILES');
  
  if (!processedFiles) {
    Logger.log('No files have been processed yet.');
    return;
  }
  
  var parsed = JSON.parse(processedFiles);
  var stats = {success: 0, error: 0, unsupported: 0};
  
  Object.keys(parsed).forEach(function(fileId) {
    stats[parsed[fileId].status]++;
  });
  
  Logger.log('üìä Processing Status:');
  Logger.log('‚úÖ Success: ' + stats.success);
  Logger.log('‚ùå Errors: ' + stats.error); 
  Logger.log('üö´ Unsupported: ' + stats.unsupported);
  Logger.log('üìÅ Total: ' + Object.keys(parsed).length);
}
